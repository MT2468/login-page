<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MTube</title>
  <meta name="description" content="MTube: v√≠deos, clips e upload com experi√™ncia inspirada no YouTube.">
  <meta name="theme-color" content="#0f172a">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0f172a;
      --surface: #111827;
      --surface-2: #1f2937;
      --text: #e5e7eb;
      --muted: #cbd5e1;
      --accent: #3b82f6;
      --accent-strong: #2563eb;
      --danger: #ef4444;
      --success: #22c55e;
      --card: #0b1220;
      --radius: 12px;
      --shadow: 0 18px 40px rgba(0,0,0,0.32);
      --font-scale: 1;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      color-scheme: dark;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: radial-gradient(circle at 20% 20%, rgba(59,130,246,0.18), transparent 35%),
                  radial-gradient(circle at 80% 10%, rgba(16,185,129,0.12), transparent 30%),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
      overflow-x: hidden;
      font-size: calc(16px * var(--font-scale));
    }
    body[data-theme="light"] {
      --bg: #f8fafc;
      --surface: #ffffff;
      --surface-2: #e2e8f0;
      --text: #0f172a;
      --muted: #475569;
      --card: #f1f5f9;
      color-scheme: light;
      background: #f8fafc;
    }
    body[data-theme="light"] .sidebar {
      background: rgba(255,255,255,0.9);
      border-right: 1px solid rgba(15,23,42,0.08);
    }
    body[data-theme="light"] header.topbar {
      background: rgba(248,250,252,0.95);
      border-bottom: 1px solid rgba(15,23,42,0.08);
    }
    body[data-theme="light"] .search-box {
      background: rgba(15,23,42,0.04);
      border: 1px solid rgba(15,23,42,0.1);
    }
    body[data-theme="light"] .video-card,
    body[data-theme="light"] .player,
    body[data-theme="light"] .comments-box,
    body[data-theme="light"] .modal,
    body[data-theme="light"] .panel,
    body[data-theme="light"] .settings-card {
      background: var(--surface);
      border: 1px solid rgba(15,23,42,0.08);
    }
    body[data-theme="light"] .hero-card,
    body[data-theme="light"] .thumb,
    body[data-theme="light"] .channel-about,
    body[data-theme="light"] .chapters,
    body[data-theme="light"] .transcript-box {
      background: var(--card);
      border: 1px solid rgba(15,23,42,0.08);
    }
    body[data-theme="light"] .chip,
    body[data-theme="light"] .pill-btn,
    body[data-theme="light"] .filter-pill {
      border-color: rgba(15,23,42,0.12);
      background: rgba(15,23,42,0.04);
      color: var(--text);
    }
    body[data-contrast="high"] {
      --bg: #000000;
      --surface: #0b0b0b;
      --surface-2: #111111;
      --text: #ffffff;
      --muted: #e2e8f0;
      --card: #0b0b0b;
      --accent: #22d3ee;
      --accent-strong: #06b6d4;
      --danger: #f87171;
      --success: #4ade80;
    }
    a { color: inherit; text-decoration: none; }
    button { font-family: inherit; }
    .hidden { display: none !important; }
    .app-shell {
      display: grid;
      grid-template-columns: 280px 1fr;
      min-height: 100vh;
    }
    .sidebar {
      background: rgba(17,24,39,0.8);
      border-right: 1px solid rgba(255,255,255,0.05);
      padding: 20px 18px;
      backdrop-filter: blur(12px);
      position: sticky;
      top: 0;
      height: 100vh;
    }
    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
      letter-spacing: -0.4px;
      font-size: 18px;
      margin-bottom: 24px;
    }
    .logo-circle {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: linear-gradient(120deg, #3b82f6, #a855f7);
      display: grid;
      place-items: center;
      color: #fff;
      font-weight: 800;
    }
    .nav-group { margin-bottom: 26px; }
    .nav-label { text-transform: uppercase; font-size: 12px; color: var(--muted); margin-bottom: 10px; letter-spacing: 0.6px; }
    .nav-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 10px;
      cursor: pointer;
      color: var(--text);
      transition: background 0.2s ease, transform 0.1s ease;
    }
    .nav-item:hover { background: rgba(255,255,255,0.06); }
    .nav-item.active { background: rgba(59,130,246,0.18); color: #dbeafe; }
    header.topbar {
      position: sticky;
      top: 0;
      z-index: 10;
      background: rgba(11,18,32,0.92);
      border-bottom: 1px solid rgba(255,255,255,0.04);
      padding: 12px 20px;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 16px;
      align-items: center;
      backdrop-filter: blur(12px);
    }
    .search-box {
      display: grid;
      grid-template-columns: 1fr auto;
      background: rgba(255,255,255,0.05);
      border-radius: 999px;
      padding: 6px;
      align-items: center;
      gap: 6px;
      border: 1px solid rgba(255,255,255,0.08);
    }
    .search-box input {
      background: transparent;
      border: none;
      color: var(--text);
      padding: 8px 12px;
      outline: none;
      font-size: 14px;
    }
    .pill-btn {
      border: none;
      background: rgba(59,130,246,0.18);
      color: #dbeafe;
      padding: 8px 14px;
      border-radius: 999px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.1s ease, background 0.2s ease;
    }
    .pill-btn:hover { background: rgba(59,130,246,0.28); }
    .topbar-actions {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .user-chip {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .icon-btn {
      position: relative;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      color: var(--text);
      width: 40px;
      height: 40px;
      border-radius: 12px;
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: background 0.2s ease, transform 0.1s ease;
    }
    .icon-btn:hover { background: rgba(255,255,255,0.1); }
    .notif-wrapper { position: relative; }
    .notif-badge {
      position: absolute;
      top: -4px;
      right: -4px;
      background: #ef4444;
      color: #fff;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 999px;
      font-weight: 700;
      min-width: 18px;
      text-align: center;
    }
    .notif-panel {
      position: absolute;
      right: 0;
      top: 52px;
      width: 320px;
      max-height: 380px;
      overflow: auto;
      background: #0b1220;
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      box-shadow: 0 16px 40px rgba(0,0,0,0.4);
      padding: 12px;
    }
    .notif-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    .notif-list {
      display: grid;
      gap: 10px;
    }
    .notif-item {
      display: grid;
      grid-template-columns: 60px 1fr;
      gap: 10px;
      padding: 8px;
      border-radius: 12px;
      background: rgba(255,255,255,0.03);
      cursor: pointer;
      border: 1px solid transparent;
      transition: border 0.2s ease, transform 0.1s ease;
    }
    .notif-item:hover { border-color: rgba(59,130,246,0.35); transform: translateY(-1px); }
    .notif-thumb {
      width: 60px;
      height: 42px;
      border-radius: 8px;
      object-fit: cover;
    }
    .notif-meta { font-size: 12px; color: var(--muted); }
    .notif-unread { border-color: rgba(59,130,246,0.5); background: rgba(59,130,246,0.12); }
    .notif-empty {
      text-align: center;
      color: var(--muted);
      font-size: 13px;
      padding: 12px 6px;
    }
    .pill-btn:active { transform: translateY(1px); }
    main.content { padding: 20px; }
    .hero {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 14px;
      margin-bottom: 20px;
    }
    .hero-card {
      padding: 16px;
      background: linear-gradient(130deg, rgba(59,130,246,0.12), rgba(168,85,247,0.08));
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }
    .hero-card h2 { margin: 0 0 8px; }
    .filters { display: flex; flex-wrap: wrap; gap: 10px; margin: 6px 0 14px; }
    .filter-pill {
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--muted);
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .filter-pill.active { background: rgba(59,130,246,0.18); color: #e5edff; border-color: rgba(59,130,246,0.5); }
    .filter-controls { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin: 4px 0 14px; }
    .filter-controls .field { margin: 0; width: 220px; }
    .pagination-box {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
      margin: 12px 0 6px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: var(--radius);
      background: rgba(255,255,255,0.02);
    }
    .pagination-actions { display: flex; gap: 8px; align-items: center; }
    .pagination-info { color: var(--muted); font-size: 14px; }
    .skeleton { position: relative; overflow: hidden; background: rgba(255,255,255,0.04); }
    .skeleton::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.08), transparent);
      animation: shimmer 1.3s infinite;
    }
    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    .skeleton-thumb { width: 100%; aspect-ratio: 16/9; border-radius: 10px; }
    .skeleton-line { height: 10px; border-radius: 6px; margin-top: 8px; }
    .search-results-box {
      background: rgba(17,24,39,0.7);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 12px;
      margin: 10px 0 14px;
    }
    .search-results-head { display: flex; justify-content: space-between; gap: 12px; flex-wrap: wrap; align-items: center; }
    .search-results-actions { display: flex; gap: 8px; flex-wrap: wrap; }
    .search-results-list { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; }
    .search-chip { border: 1px solid rgba(255,255,255,0.12); border-radius: 10px; padding: 6px 10px; background: rgba(255,255,255,0.04); cursor: pointer; }
    .search-chip.active { background: rgba(59,130,246,0.18); border-color: rgba(59,130,246,0.5); }
    .grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .video-card {
      background: rgba(17,24,39,0.8);
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.06);
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.2s ease;
      position: relative;
    }
    .video-card:hover { transform: translateY(-3px); box-shadow: 0 12px 30px rgba(0,0,0,0.35); }
    .thumb { position: relative; aspect-ratio: 16 / 9; background: #0f172a; }
    .thumb img { width: 100%; height: 100%; object-fit: cover; display: block; }
    .thumb .badge { position: absolute; bottom: 8px; right: 8px; background: rgba(0,0,0,0.65); padding: 4px 8px; border-radius: 8px; font-size: 12px; }
    .card-body { padding: 12px; display: grid; grid-template-columns: auto 1fr; gap: 10px; }
    .avatar { width: 36px; height: 36px; border-radius: 50%; background: linear-gradient(120deg,#3b82f6,#a855f7); display:grid; place-items:center; font-weight:700; color:#fff; }
    .avatar.img { background: #0f172a; padding: 0; overflow: hidden; }
    .avatar.img img { width: 100%; height: 100%; object-fit: cover; display: block; }
    .avatar.lg { width: 72px; height: 72px; font-size: 22px; }
    .card-text h4 { margin: 0; font-size: 15px; }
    .card-text p { margin: 4px 0 0; color: var(--muted); font-size: 13px; }
    .section-title { margin: 16px 0 10px; font-weight: 700; letter-spacing: -0.2px; }
    .recommendations, .tracks-row, .explore-row { display: flex; gap: 12px; overflow-x: auto; padding-bottom: 6px; scrollbar-width: thin; }
    .recommendations::-webkit-scrollbar, .tracks-row::-webkit-scrollbar, .explore-row::-webkit-scrollbar { height: 8px; }
    .recommendations::-webkit-scrollbar-thumb, .tracks-row::-webkit-scrollbar-thumb, .explore-row::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 999px; }
    .explore-row .video-card { min-width: 240px; flex: 0 0 auto; }
    .track-card { min-width: 240px; background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.06); border-radius: 12px; padding: 12px; cursor: pointer; transition: transform 0.15s ease, background 0.2s ease; }
    .track-card:hover { transform: translateY(-2px); background: rgba(255,255,255,0.06); }
    .track-card h4 { margin: 0 0 6px; }
    .track-meta { display: flex; gap: 8px; align-items: center; color: var(--muted); font-size: 13px; }
    /* Canal */
    .channel-view { display: grid; gap: 18px; }
    .channel-banner {
      border-radius: 18px;
      padding: 24px;
      background: linear-gradient(120deg, rgba(59,130,246,0.3), rgba(168,85,247,0.25));
      border: 1px solid rgba(255,255,255,0.08);
    }
    .channel-header {
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: 16px;
    }
    .channel-info h2 { margin: 0; }
    .channel-info p { margin: 4px 0 0; color: var(--muted); }
    .channel-tabs {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .channel-tab {
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      color: var(--text);
      padding: 8px 14px;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 600;
    }
    .channel-tab.active {
      background: rgba(59,130,246,0.2);
      border-color: rgba(59,130,246,0.5);
    }
    .channel-about {
      background: var(--card-bg);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 14px;
      color: var(--muted);
    }
    /* Watch page */
    .watch-page { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; margin-top: 10px; }
    .player {
      background: #0f172a;
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 14px;
    }
    .player .player-frame { position: relative; aspect-ratio: 16 / 9; border-radius: 12px; overflow: hidden; background: #0b1220; display:grid; place-items:center; color: var(--muted); }
    .player .bar { position: absolute; bottom: 0; left: 0; height: 5px; background: #ef4444; width: 100%; }
    .player-status { position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.6); padding: 6px 10px; border-radius: 8px; font-size: 13px; color: #e5e7eb; }
    .watch-meta { margin-top: 10px; }
    .actions { display: flex; gap: 10px; flex-wrap: wrap; margin: 10px 0; }
    .chip { padding: 8px 12px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.12); cursor: pointer; background: rgba(255,255,255,0.05); }
    .chip.active { background: rgba(59,130,246,0.18); border-color: rgba(59,130,246,0.6); }
    .channel-link {
      border: none;
      background: none;
      color: #e2e8f0;
      font-weight: 700;
      padding: 0;
      cursor: pointer;
      text-align: left;
    }
    .channel-link:hover { text-decoration: underline; }
    .chapters { border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 12px; margin-top: 12px; background: var(--card-bg); }
    .chapters h4 { margin: 0 0 8px; }
    .chapters p { margin: 0 0 12px; color: var(--muted); }
    .chapters-list { display: flex; flex-direction: column; gap: 8px; }
    .chapter-link { display: flex; align-items: center; gap: 8px; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.04); cursor: pointer; text-align: left; color: var(--text); }
    .chapter-time { font-weight: 700; color: #93c5fd; }
    .transcript-box { border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 12px; margin-top: 12px; background: var(--card-bg); display: flex; flex-direction: column; gap: 10px; }
    .transcript-head { display: flex; align-items: center; justify-content: space-between; gap: 10px; flex-wrap: wrap; }
    .transcript-head h4 { margin: 0; }
    .transcript-head p { margin: 0; color: var(--muted); }
    .transcript-search { padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.06); color: var(--text); min-width: 200px; }
    .transcript-list { display: flex; flex-direction: column; gap: 8px; max-height: 260px; overflow: auto; }
    .transcript-item { border: 1px solid rgba(255,255,255,0.08); padding: 8px 10px; border-radius: 10px; display: grid; grid-template-columns: auto 1fr; gap: 8px; cursor: pointer; }
    .transcript-item.active { border-color: #3b82f6; background: rgba(59,130,246,0.08); }
    .transcript-item .timestamp { font-weight: 700; color: #93c5fd; }
    .suggestions { display: grid; gap: 12px; }
    .up-next { margin-bottom: 16px; }
    .up-next-header { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 8px; }
    .up-next-card { border: 1px solid rgba(255,255,255,0.1); background: rgba(17,24,39,0.9); }
    .up-next-list { display: grid; gap: 10px; margin-top: 10px; }
    .autoplay-row { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin: 6px 0 12px; }
    .comments-box { margin-top: 18px; background: rgba(17,24,39,0.85); border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 14px; }
    .comments-box h4 { margin: 0 0 10px; }
    .comment-form { display: grid; gap: 10px; margin-bottom: 12px; }
    .comment-form textarea { width: 100%; min-height: 80px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.04); color: var(--text); padding: 10px; resize: vertical; }
    .comment-form button { justify-self: flex-end; }
    .comment-list { display: grid; gap: 10px; }
    .comment-item { border: 1px solid rgba(255,255,255,0.06); border-radius: 10px; padding: 10px; background: rgba(255,255,255,0.02); }
    .comment-head { display: flex; justify-content: flex-start; align-items: center; gap: 10px; font-size: 13px; color: var(--muted); }
    .comment-actions { display: flex; gap: 8px; margin-top: 8px; }
    .comment-actions button { border-radius: 999px; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.04); color: var(--text); padding: 6px 10px; cursor: pointer; font-size: 12px; }
    .comment-actions button.active { background: rgba(59,130,246,0.18); border-color: rgba(59,130,246,0.5); }
    /* Forms */
    .auth-wrapper { min-height: 100vh; display: grid; place-items: center; padding: 20px; }
    .panel { width: 100%; max-width: 420px; background: rgba(17,24,39,0.9); border: 1px solid rgba(255,255,255,0.08); border-radius: 16px; padding: 24px; box-shadow: var(--shadow); }
    .panel h1 { margin: 0 0 6px; }
    .panel p { margin: 0 0 16px; color: var(--muted); }
    .field { display: grid; gap: 6px; margin-bottom: 12px; }
    .field.remember-row { display: inline-flex; align-items: center; gap: 8px; margin-bottom: 16px; }
    .field.remember-row input { width: auto; }
    .field label { font-size: 14px; color: var(--muted); }
    .field input, .field select, .field textarea {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(255,255,255,0.04);
      color: var(--text);
    }
    .btn { border: none; padding: 12px 14px; border-radius: 12px; cursor: pointer; font-weight: 700; }
    .btn.primary { background: linear-gradient(120deg, #2563eb, #3b82f6); color: #fff; width: 100%; }
    .btn.secondary { background: rgba(255,255,255,0.06); color: var(--text); }
    .link { color: #93c5fd; cursor: pointer; }
    .toast { position: fixed; bottom: 18px; right: 18px; background: #111827; border: 1px solid rgba(255,255,255,0.08); padding: 12px 14px; border-radius: 12px; box-shadow: var(--shadow); display: none; }
    /* Upload modal */
    .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; z-index: 20; }
    .modal { background: rgba(17,24,39,0.95); border: 1px solid rgba(255,255,255,0.08); border-radius: 16px; padding: 18px; width: min(640px, 92vw); box-shadow: var(--shadow); }
    .thumb-gallery { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px,1fr)); gap: 10px; margin-top: 8px; }
    .thumb-option { border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; overflow: hidden; cursor: pointer; position: relative; }
    .thumb-option img { width: 100%; display: block; height: 80px; object-fit: cover; }
    .thumb-option input { position: absolute; inset: 0; opacity: 0; cursor: pointer; }
    .tag { display: inline-block; padding: 4px 8px; border-radius: 10px; background: rgba(255,255,255,0.06); font-size: 12px; margin-left: 6px; }
    .avatar-picker { display: grid; grid-template-columns: repeat(auto-fit,minmax(88px,1fr)); gap: 10px; margin-top: 8px; }
    .avatar-option { border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; padding: 8px; text-align: center; cursor: pointer; background: rgba(255,255,255,0.02); }
    .avatar-option input { display: none; }
    .avatar-option.active { border-color: rgba(59,130,246,0.6); background: rgba(59,130,246,0.08); }
    .profile-preview { display: flex; align-items: center; gap: 10px; margin-top: 8px; }
    .settings-grid { display: grid; gap: 16px; }
    .settings-card {
      background: var(--surface);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 14px;
    }
    .settings-card h4 { margin: 0 0 8px; }
    .settings-row { display: grid; gap: 10px; }
    .settings-actions { display: flex; gap: 10px; flex-wrap: wrap; justify-content: flex-end; margin-top: 12px; }
    @media (max-width: 900px) {
      .app-shell { grid-template-columns: 1fr; }
      .sidebar { height: auto; position: relative; }
      .watch-page { grid-template-columns: 1fr; }
      .channel-header { grid-template-columns: 1fr; justify-items: flex-start; }
      .transcript-list { max-height: 200px; }
      .transcript-head { flex-direction: column; align-items: flex-start; }
    }

    /* Quebra focada em tablets e celulares: reduz paddings, reorganiza navega√ß√£o e cards para melhorar usabilidade ao toque. */
    @media (max-width: 640px) {
      main.content { padding: 14px; }
      header.topbar { grid-template-columns: 1fr; gap: 10px; padding: 10px 14px; }
      .notif-panel { width: min(92vw, 360px); right: 0; }
      .search-box { grid-template-columns: 1fr; }
      .search-box input { padding: 10px 12px; }
      .app-shell { grid-template-columns: 1fr; }
      .sidebar {
        position: relative;
        height: auto;
        padding: 12px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }
      .nav-group { margin: 0; display: flex; gap: 8px; flex-wrap: wrap; }
      .nav-label { width: 100%; margin-bottom: 4px; }
      .nav-item { padding: 8px 10px; }
      .hero { grid-template-columns: 1fr; }
      .filter-controls { flex-direction: column; align-items: stretch; }
      .filter-controls .field { width: 100%; }
      .pagination-box { padding: 10px; }
      .pagination-actions { width: 100%; justify-content: flex-start; }
      .grid { grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
      .card-body { grid-template-columns: auto 1fr; gap: 8px; }
      .watch-page { gap: 14px; }
      .actions { gap: 6px; }
      .recommendations, .tracks-row { gap: 10px; }
      .panel { padding: 18px; }
      .comments-box { padding: 12px; }
      .comment-head { flex-direction: column; align-items: flex-start; }
    }

    /* Foco em aparelhos muito pequenos: apertar grid e hero para caber sem zoom. */
    @media (max-width: 480px) {
      main.content { padding: 10px; }
      .hero { grid-template-columns: 1fr; gap: 12px; }
      .filter-controls { flex-direction: column; align-items: stretch; gap: 10px; }
      .filter-controls .field { width: 100%; }
      .grid { grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px; }
      .pagination-box { padding: 8px 10px; }
      .pagination-actions { width: 100%; justify-content: space-between; }
      .sidebar { padding: 10px; }
      .search-box { grid-template-columns: 1fr; }
      header.topbar { padding: 10px; }
      .notif-panel { width: min(92vw, 320px); right: -4px; }
    }
  </style>
</head>
<body>
  <div class="toast" id="toast"></div>
  <div class="auth-wrapper" id="login-view">
    <div class="panel">
      <h1>Entrar no MTube</h1>
      <p>Acesse sua conta para publicar, assistir e salvar clipes.</p>
      <form id="login-form">
        <div class="field">
          <label for="login-username">Usu√°rio</label>
          <input id="login-username" name="username" required>
        </div>
        <div class="field">
          <label for="login-password">Senha</label>
          <input id="login-password" name="password" type="password" required>
        </div>
        <label class="field remember-row" for="remember">
          <input id="remember" type="checkbox">
          <span>Lembre-se de mim</span>
        </label>
        <button class="btn primary" type="submit">Entrar</button>
      </form>
      <p>N√£o tem conta? <span class="link" id="go-signup">Criar conta</span></p>
    </div>
  </div>
  <div class="auth-wrapper hidden" id="signup-view">
    <div class="panel">
      <h1>Criar conta</h1>
      <p>Cadastre-se para come√ßar a enviar seus v√≠deos.</p>
      <form id="signup-form">
        <div class="field">
          <label for="signup-username">Usu√°rio</label>
          <input id="signup-username" name="username" required>
        </div>
        <div class="field">
          <label for="signup-password">Senha</label>
          <input id="signup-password" name="password" type="password" minlength="4" required>
        </div>
        <div class="field">
          <label for="signup-display">Nome p√∫blico</label>
          <input id="signup-display" name="display" required>
        </div>
        <button class="btn primary" type="submit">Cadastrar</button>
      </form>
      <p>J√° tem conta? <span class="link" id="back-login">Voltar</span></p>
    </div>
  </div>
  <div class="app-shell hidden" id="app">
    <aside class="sidebar">
      <div class="logo"><div class="logo-circle">M</div><span>MTube</span></div>
      <div class="nav-group">
        <div class="nav-label">Principal</div>
        <div class="nav-item active" data-view="home">In√≠cio</div>
        <div class="nav-item" data-view="explore">Explorar</div>
        <div class="nav-item" data-view="subscriptions">Inscri√ß√µes</div>
        <div class="nav-item" data-view="clips">Clipes</div>
        <div class="nav-item" data-view="upload">Enviar v√≠deo</div>
      </div>
      <div class="nav-group">
        <div class="nav-label">Conta</div>
        <div class="nav-item" id="nav-profile">Perfil</div>
        <div class="nav-item" data-view="settings">Configura√ß√µes</div>
        <div class="nav-item" id="nav-logout">Sair</div>
      </div>
    </aside>
    <div>
      <header class="topbar">
        <div class="search-box">
          <input id="search" placeholder="Buscar v√≠deos">
          <button class="pill-btn" id="search-btn">Buscar</button>
        </div>
        <div class="topbar-actions">
          <button class="pill-btn" id="open-upload">Criar</button>
          <div class="notif-wrapper">
            <button class="icon-btn" id="notif-btn" type="button" aria-label="Abrir notifica√ß√µes" aria-haspopup="dialog" aria-expanded="false">
              üîî
              <span id="notif-badge" class="notif-badge" aria-hidden="true"></span>
            </button>
            <div id="notif-panel" class="notif-panel hidden" role="dialog" aria-label="Notifica√ß√µes" aria-hidden="true">
              <div class="notif-header">
                <strong>Notifica√ß√µes</strong>
                <button class="pill-btn secondary" id="notif-mark-read" type="button">Marcar como lidas</button>
              </div>
              <div id="notif-list" class="notif-list"></div>
              <div id="notif-empty" class="notif-empty hidden">Sem notifica√ß√µes no momento.</div>
            </div>
          </div>
          <div id="user-chip" class="chip user-chip">
            <span id="user-chip-avatar" class="avatar" aria-hidden="true">U</span>
            <span>Entrou como <strong id="user-name">usu√°rio</strong></span>
          </div>
        </div>
      </header>
      <main class="content">
        <section id="home-view">
          <div class="hero">
            <div class="hero-card">
              <h2>Descubra e publique</h2>
              <p>Home inspirada no YouTube, com feed personalizado e navega√ß√£o r√°pida.</p>
              <button class="pill-btn" id="from-hero-upload">Publicar agora</button>
            </div>
            <div class="hero-card">
              <h2>Clipes offline</h2>
              <p>Salve momentos curtos para assistir sem internet.</p>
              <span class="tag">Beta</span>
            </div>
            <div class="hero-card">
              <h2>Notifica√ß√µes inteligentes</h2>
              <p>Receba alertas de canais e categorias que voc√™ segue.</p>
            </div>
          </div>
          <div id="categories" class="filters hidden"></div>
          <div class="filters">
            <div class="filter-pill active" data-filter="all">Todos</div>
            <div class="filter-pill" data-filter="Entretenimento">Entretenimento</div>
            <div class="filter-pill" data-filter="Filmes & TV">Filmes & TV</div>
            <div class="filter-pill" data-filter="Games">Games</div>
            <div class="filter-pill" data-filter="M√∫sica">M√∫sica</div>
            <div class="filter-pill" data-filter="Esportes">Esportes</div>
          </div>
          <div class="filter-controls">
            <div class="field">
              <label for="order-select">Ordena√ß√£o</label>
              <select id="order-select">
                <option value="recentes">Mais recentes</option>
                <option value="views">Mais vistos</option>
                <option value="avaliados">Melhor avaliados</option>
              </select>
            </div>
            <div class="field">
              <label for="duration-select">Dura√ß√£o</label>
              <select id="duration-select">
                <option value="todas">Todas</option>
                <option value="curtas">At√© 4 min</option>
                <option value="medias">5 a 10 min</option>
                <option value="longas">Acima de 10 min</option>
              </select>
            </div>
          </div>
          <div id="search-results-box" class="search-results-box hidden">
            <div class="search-results-head">
              <div>
                <strong id="search-summary"></strong>
                <p id="search-detail" style="color:var(--muted);margin:4px 0 0;"></p>
              </div>
              <div class="search-results-actions">
                <button class="pill-btn secondary" id="prev-result" type="button">Anterior</button>
                <button class="pill-btn secondary" id="next-result" type="button">Pr√≥ximo</button>
                <button class="pill-btn" id="open-current" type="button">Abrir</button>
                <button class="pill-btn secondary" id="clear-search" type="button">Limpar</button>
              </div>
            </div>
            <div id="search-results-list" class="search-results-list"></div>
          </div>
          <div id="recommend-box" class="hidden">
            <h3 class="section-title">Recomendados para voc√™</h3>
            <div class="recommendations" id="recommendations"></div>
          </div>
          <div id="tracks-box" class="hidden">
            <h3 class="section-title">Trilhas tem√°ticas</h3>
            <div class="tracks-row" id="tracks-row"></div>
          </div>
          <h3 class="section-title">V√≠deos</h3>
          <div class="pagination-box" id="grid-pagination" aria-live="polite">
            <div class="pagination-info" id="grid-summary">Carregando...</div>
            <div class="pagination-actions">
              <button class="pill-btn secondary" id="grid-prev" type="button">Anterior</button>
              <button class="pill-btn secondary" id="grid-next" type="button">Pr√≥ximo</button>
            </div>
          </div>
          <div class="grid" id="video-grid"></div>
        </section>
        <section id="watch-view" class="hidden">
          <div class="watch-page">
            <div>
              <div class="player">
                <div class="player-frame" id="player-frame">
                  <div id="player-thumb"></div>
                  <div style="position:absolute;inset:0;display:grid;place-items:center;">
                    <div style="background:rgba(0,0,0,0.6);padding:10px 14px;border-radius:10px;">O v√≠deo n√£o est√° dispon√≠vel por limita√ß√µes do site.</div>
                  </div>
                  <div class="player-status" id="player-status">Pausado ¬∑ 0:00</div>
                  <div class="bar" id="player-progress"></div>
                </div>
                <div class="watch-meta">
                  <h2 id="watch-title"></h2>
                  <p id="watch-stats" style="color:var(--muted);"></p>
                  <div id="watch-author" style="display:flex;align-items:center;gap:10px;margin:6px 0 12px;"></div>
                  <div class="actions" style="flex-wrap:wrap;gap:8px;">
                    <div class="chip" id="action-like">Curtir (<span id="like-count">0</span>)</div>
                    <div class="chip" id="action-dislike">N√£o curtir (<span id="dislike-count">0</span>)</div>
                    <div class="chip" id="action-subscribe">Inscrever-se</div>
                    <div class="chip" id="action-watchlater">Assistir depois</div>
                    <div class="chip" id="action-offline">Salvar offline</div>
                    <div class="chip" id="action-playlist">Adicionar √† playlist</div>
                    <div class="chip" id="action-history">Salvar hist√≥rico</div>
                  </div>
                  <div class="autoplay-row">
                    <span style="color:var(--muted);font-size:14px;">Reprodu√ß√£o autom√°tica</span>
                    <button class="pill-btn ghost" id="autoplay-toggle" type="button" aria-pressed="true">Ativada</button>
                  </div>
                  <div class="chapters">
                    <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;">
                      <div>
                        <h4 style="margin:0;">Cap√≠tulos</h4>
                        <p id="chapters-summary">Gerado a partir da descri√ß√£o.</p>
                      </div>
                    </div>
                    <div class="chapters-list" id="chapters-list"></div>
                  </div>
                  <div class="transcript-box">
                    <div class="transcript-head">
                      <div>
                        <h4>Transcri√ß√£o</h4>
                        <p id="transcript-summary">Linhas sincronizadas.</p>
                      </div>
                      <input id="transcript-search" class="transcript-search" placeholder="Buscar na transcri√ß√£o" aria-label="Buscar na transcri√ß√£o">
                    </div>
                    <div class="transcript-list" id="transcript-list"></div>
                  </div>
                  <div id="watch-desc" style="color:var(--muted);"></div>
                  <div class="comments-box">
                    <h4>Coment√°rios</h4>
                    <form id="comment-form" class="comment-form">
                      <label for="comment-text" style="color:var(--muted);">Compartilhe sua opini√£o</label>
                      <textarea id="comment-text" placeholder="Escreva um coment√°rio" required></textarea>
                      <button class="pill-btn" type="submit">Publicar coment√°rio</button>
                    </form>
                    <div id="comments-list" class="comment-list"></div>
                  </div>
                </div>
              </div>
            </div>
            <aside>
              <div class="up-next">
                <div class="up-next-header">
                  <h4 style="margin:0;">A seguir</h4>
                </div>
                <div id="up-next"></div>
                <div id="up-next-list" class="up-next-list"></div>
              </div>
              <h4>Sugeridos</h4>
              <div class="suggestions" id="suggestions"></div>
            </aside>
          </div>
        </section>
        <section id="channel-view" class="hidden">
          <div class="channel-view">
            <div class="channel-banner">
              <div class="channel-header">
                <div id="channel-avatar" class="avatar lg">C</div>
                <div class="channel-info">
                  <h2 id="channel-name">Canal</h2>
                  <p id="channel-meta">0 v√≠deos ¬∑ 0 visualiza√ß√µes</p>
                </div>
                <button class="pill-btn" id="channel-subscribe" type="button">Inscrever-se</button>
              </div>
            </div>
            <div class="channel-tabs" role="tablist" aria-label="Se√ß√µes do canal">
              <button class="channel-tab active" data-tab="inicio" type="button" role="tab" aria-selected="true">In√≠cio</button>
              <button class="channel-tab" data-tab="videos" type="button" role="tab" aria-selected="false">V√≠deos</button>
              <button class="channel-tab" data-tab="playlists" type="button" role="tab" aria-selected="false">Playlists</button>
              <button class="channel-tab" data-tab="sobre" type="button" role="tab" aria-selected="false">Sobre</button>
            </div>
            <div id="channel-section-inicio" class="channel-section">
              <h3 class="section-title">Destaques do canal</h3>
              <div class="grid" id="channel-featured"></div>
            </div>
            <div id="channel-section-videos" class="channel-section hidden">
              <h3 class="section-title">Todos os v√≠deos</h3>
              <div class="grid" id="channel-videos"></div>
            </div>
            <div id="channel-section-playlists" class="channel-section hidden">
              <h3 class="section-title">Playlists</h3>
              <div class="channel-about">Em breve: playlists p√∫blicas do canal com organiza√ß√£o por s√©ries.</div>
            </div>
            <div id="channel-section-sobre" class="channel-section hidden">
              <h3 class="section-title">Sobre</h3>
              <div id="channel-about" class="channel-about"></div>
            </div>
          </div>
        </section>
        <section id="subscriptions-view" class="hidden">
          <h3 class="section-title">Inscri√ß√µes</h3>
          <p id="subscriptions-summary" style="color:var(--muted);margin-top:4px;">Carregando inscri√ß√µes...</p>
          <div id="subscriptions-empty" class="hidden" style="color:var(--muted);margin:12px 0 18px;">
            Inscreva-se em canais para ver um feed personalizado aqui.
          </div>
          <div class="grid" id="subscriptions-grid"></div>
        </section>
        <section id="explore-view" class="hidden">
          <h3 class="section-title">Explorar</h3>
          <p id="explore-summary" style="color:var(--muted);margin-top:4px;">Carregando listas tem√°ticas...</p>
          <div id="explore-rows"></div>
        </section>
        <section id="settings-view" class="hidden">
          <h3 class="section-title">Configura√ß√µes</h3>
          <p style="color:var(--muted);margin-top:4px;">Personalize sua experi√™ncia, privacidade e notifica√ß√µes.</p>
          <form id="settings-form" class="settings-grid">
            <div class="settings-card">
              <h4>Prefer√™ncias visuais</h4>
              <div class="settings-row">
                <div class="field">
                  <label for="setting-theme">Tema</label>
                  <select id="setting-theme">
                    <option value="dark">Escuro</option>
                    <option value="light">Claro</option>
                  </select>
                </div>
                <div class="field">
                  <label for="setting-contrast">Contraste</label>
                  <select id="setting-contrast">
                    <option value="normal">Padr√£o</option>
                    <option value="high">Alto contraste</option>
                  </select>
                </div>
                <div class="field">
                  <label for="setting-font">Tamanho da fonte</label>
                  <input id="setting-font" type="range" min="0.9" max="1.3" step="0.05">
                </div>
              </div>
            </div>
            <div class="settings-card">
              <h4>Privacidade</h4>
              <div class="settings-row">
                <label class="field remember-row">
                  <input type="checkbox" id="setting-profile">
                  <span>Exibir meu perfil para outros usu√°rios</span>
                </label>
              </div>
            </div>
            <div class="settings-card">
              <h4>Notifica√ß√µes</h4>
              <div class="settings-row">
                <label class="field remember-row">
                  <input type="checkbox" id="setting-push">
                  <span>Receber alertas de novos v√≠deos</span>
                </label>
                <label class="field remember-row">
                  <input type="checkbox" id="setting-digest">
                  <span>Receber resumo di√°rio de novidades</span>
                </label>
              </div>
            </div>
            <div class="settings-actions">
              <button class="btn secondary" type="button" id="settings-reset">Restaurar padr√£o</button>
              <button class="btn primary" type="submit">Salvar configura√ß√µes</button>
            </div>
          </form>
        </section>
        <section id="clips-view" class="hidden">
          <div class="section-title" style="display:flex;align-items:center;gap:12px;justify-content:space-between;flex-wrap:wrap;">
            <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
              <h3 style="margin:0;">Clipes</h3>
              <div class="chip" id="tab-clips" aria-pressed="true">Clipes</div>
              <div class="chip" id="tab-watchlater" aria-pressed="false">Assistir depois</div>
              <div class="chip" id="tab-playlists" aria-pressed="false">Playlists</div>
              <div class="chip" id="tab-history" aria-pressed="false">Hist√≥rico</div>
            </div>
            <div id="watchlater-filters" class="hidden" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
              <label for="wl-category" style="color:var(--muted);font-size:13px;">Categoria</label>
              <select id="wl-category" style="padding:6px 8px;border-radius:8px;border:1px solid #2a2a2a;background:var(--card-bg);color:#fff;">
                <option value="all">Todas</option>
                <option value="Entretenimento">Entretenimento</option>
                <option value="Filmes & TV">Filmes & TV</option>
                <option value="Games">Games</option>
                <option value="M√∫sica">M√∫sica</option>
                <option value="Esportes">Esportes</option>
              </select>
              <label for="wl-order" style="color:var(--muted);font-size:13px;">Ordenar</label>
              <select id="wl-order" style="padding:6px 8px;border-radius:8px;border:1px solid #2a2a2a;background:var(--card-bg);color:#fff;">
                <option value="recentes">Mais recentes</option>
                <option value="views">Mais vistos</option>
                <option value="avaliados">Melhor avaliados</option>
              </select>
            </div>
          </div>
          <div class="grid" id="clips-grid"></div>
          <div class="grid hidden" id="watchlater-grid"></div>
          <div class="grid hidden" id="playlist-grid"></div>
          <div class="grid hidden" id="history-grid"></div>
        </section>
      </main>
    </div>
  </div>
  <div class="modal-backdrop" id="upload-modal">
    <div class="modal">
      <h3>Enviar v√≠deo</h3>
      <form id="upload-form">
        <div class="field">
          <label for="video-title">T√≠tulo</label>
          <input id="video-title" required>
        </div>
        <div class="field">
          <label for="video-desc">Descri√ß√£o</label>
          <textarea id="video-desc" rows="3" required></textarea>
        </div>
        <div class="field">
          <label for="video-duration">Dura√ß√£o (min)</label>
          <input id="video-duration" type="number" min="1" value="3" required>
        </div>
        <div class="field">
          <label for="video-category">Categoria</label>
          <select id="video-category">
            <option>Entretenimento</option>
            <option>Filmes & TV</option>
            <option>Games</option>
            <option>M√∫sica</option>
            <option>Esportes</option>
          </select>
        </div>
        <div class="field">
          <label>Escolha uma thumbnail</label>
          <div class="thumb-gallery" id="thumb-gallery"></div>
        </div>
        <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:12px;">
          <button class="btn secondary" type="button" id="cancel-upload">Cancelar</button>
          <button class="btn primary" type="submit">Publicar</button>
        </div>
      </form>
    </div>
  </div>
  <div class="modal-backdrop" id="profile-modal">
    <div class="modal">
      <h3>Perfil e avatar</h3>
      <p style="color:var(--muted);margin-top:0;">Atualize seu nome p√∫blico e escolha um avatar. A altera√ß√£o reflete imediatamente em todos os seus v√≠deos e nos demais usu√°rios conectados.</p>
      <form id="profile-form">
        <div class="field">
          <label for="profile-display">Nome p√∫blico</label>
          <input id="profile-display" required>
        </div>
        <div class="field">
          <label for="profile-avatar">URL do avatar</label>
          <input id="profile-avatar" placeholder="https://exemplo.com/avatar.png">
          <small style="color:var(--muted);">Use um link direto de imagem ou escolha uma op√ß√£o abaixo.</small>
        </div>
        <div class="field">
          <label>Galeria de avatares</label>
          <div id="avatar-gallery" class="avatar-picker"></div>
        </div>
        <div class="profile-preview">
          <div id="profile-avatar-preview" class="avatar lg">U</div>
          <div>
            <strong id="profile-preview-name">Usu√°rio</strong>
            <p style="margin:4px 0 0;color:var(--muted);">Pr√©-visualiza√ß√£o em tempo real</p>
          </div>
        </div>
        <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:14px;">
          <button type="button" class="btn secondary" id="cancel-profile">Cancelar</button>
          <button type="submit" class="btn primary" style="width:auto;">Salvar altera√ß√µes</button>
        </div>
      </form>
    </div>
  </div>
  <script>
    // Utilidades b√°sicas
    const qs = (sel) => document.querySelector(sel);
    const qsa = (sel) => Array.from(document.querySelectorAll(sel));
    const debounce = (fn, delay = 250) => {
      let timer;
      return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => fn(...args), delay);
      };
    };
    const toastEl = qs('#toast');
    const showToast = (msg) => {
      toastEl.textContent = msg;
      toastEl.style.display = 'block';
      setTimeout(() => toastEl.style.display = 'none', 2600);
    };

    const storage = {
      load(key, fallback) {
        try { return JSON.parse(localStorage.getItem(key)) ?? fallback; } catch { return fallback; }
      },
      save(key, value) { localStorage.setItem(key, JSON.stringify(value)); }
    };

    // Seguran√ßa e hashing: detecta suporte ao Web Crypto e oferece fallback s√≠ncrono.
    const securitySupport = {
      subtleAvailable: supportsSubtleCrypto(),
      fallbackUsed: false,
    };

      const SHARED_KEY = 'mtube-shared';
      const REMOTE_BACKUP_KEY = 'mtube-remote-backup';
      // URL p√∫blica real do backend; evita .local para n√£o mascarar falhas de rede
      const REMOTE_BASE = 'https://mtube-backend.example.com/api';

      const COMMENT_KEY = 'mtube-comments';
      const WATCH_LATER_KEY = 'mtube-watch-later';
      const PLAYLIST_KEY = 'mtube-playlists';
      const HISTORY_KEY = 'mtube-history';
      const TRANSCRIPT_KEY = 'mtube-transcripts';
      const SUBSCRIPTIONS_KEY = 'mtube-subscriptions';
      const NOTIF_KEY = 'mtube-notifications';
      const META_KEY = 'mtube-meta';
      const AUTOPLAY_KEY = 'mtube-autoplay';
      const SETTINGS_KEY = 'mtube-settings';
      const COMMENT_COOLDOWN_MS = 5000;
      const SESSION_TTL_MS = 1000 * 60 * 60 * 24 * 14; // 14 dias
      const SESSION_TOKEN_TTL_MS = 1000 * 60 * 30; // token curto
      const SESSION_TOKEN_KEY = 'mtube-session-tokens';
      const DATASETS = ['users','videos','watchLater','playlists','historico','comments','transcripts','subscriptions'];

      const defaultMeta = () => ({
        users: 0,
        videos: 0,
        watchLater: 0,
        playlists: 0,
        historico: 0,
        comments: 0,
        transcripts: 0,
        subscriptions: 0,
      });
      const defaultSettings = () => ({
        theme: 'dark',
        contrast: 'normal',
        fontScale: 1,
        privacyProfile: true,
        notifPush: true,
        notifDigest: false,
      });

      // Sync simples entre abas/dispositivos: usamos localStorage como ‚Äúservidor‚Äù local
      const remoteState = { online: true, warned: false };

      const remoteBackup = {
        load: () => storage.load(REMOTE_BACKUP_KEY, null),
        save: (payload) => storage.save(REMOTE_BACKUP_KEY, payload)
      };
    function loadSharedStore() {
      return storage.load(SHARED_KEY, null);
    }

    function saveSharedStore(payload) {
      storage.save(SHARED_KEY, payload);
      if (window.BroadcastChannel) {
        sharedChannel?.postMessage({ type: 'sync', payload });
      }
    }

    function migrateLegacyStores() {
      const shared = loadSharedStore();
      const legacyUsers = storage.load('mtube-users', []);
      const legacyVideos = storage.load('mtube-videos', []);
      const legacyWatchLater = storage.load(WATCH_LATER_KEY, []);
      const legacyPlaylists = storage.load(PLAYLIST_KEY, []);
      const legacyHistorico = storage.load(HISTORY_KEY, []);
      const legacyComments = storage.load(COMMENT_KEY, {});
      const legacyTranscripts = storage.load(TRANSCRIPT_KEY, {});
      const legacySubscriptions = storage.load(SUBSCRIPTIONS_KEY, []);

      if (!shared && (legacyUsers.length || legacyVideos.length || legacyWatchLater.length || legacyPlaylists.length || legacyHistorico.length || Object.keys(legacyComments).length || Object.keys(legacyTranscripts).length || legacySubscriptions.length)) {
        const payload = {
          users: legacyUsers,
          videos: legacyVideos,
          watchLater: legacyWatchLater,
          playlists: legacyPlaylists,
          historico: legacyHistorico,
          comments: legacyComments,
          transcripts: legacyTranscripts,
          subscriptions: legacySubscriptions,
          meta: defaultMeta(),
        };
        const now = Date.now();
        DATASETS.forEach(key => { payload.meta[key] = now; });
        saveSharedStore(payload);
        return payload;
      }
      return shared;
    }

      const sharedChannel = window.BroadcastChannel ? new BroadcastChannel('mtube-shared') : null;

      const wait = (ms = 300) => new Promise(res => setTimeout(res, ms));

      function mergeCollections(localList = [], remoteList = [], key = 'id') {
        const map = new Map();
        remoteList.forEach(item => item?.[key] && map.set(item[key], item));
        localList.forEach(item => item?.[key] && map.set(item[key], item));
        return Array.from(map.values());
      }

        function flagRemoteError(err) {
          remoteState.online = false;
          console.warn('Sincroniza√ß√£o remota desativada', err);
          if (!remoteState.warned) {
            showToast('Sincroniza√ß√£o remota desativada; usando apenas cache local.');
            remoteState.warned = true;
          }
        }

        function flagRemoteOk() {
          if (!remoteState.online) {
            showToast('Conex√£o com o backend restabelecida.');
          }
          remoteState.online = true;
          remoteState.warned = false;
          if (remoteQueue.length) processRemoteQueue();
        }

        function createRemoteApi() {
          // M√≥dulo REST simples com fallback APENAS de leitura via backup local
          const request = async (path, { method = 'GET', body } = {}) => {
            const options = { method, headers: { 'Content-Type': 'application/json' } };
            if (body) options.body = JSON.stringify(body);
            try {
              const res = await fetch(`${REMOTE_BASE}/${path}`, options);
              if (!res.ok) throw new Error(`HTTP ${res.status}`);
              flagRemoteOk();
              const data = await res.json();
              if (path === 'snapshot' && method === 'GET') {
                remoteBackup.save(data);
              }
              return data;
            } catch (err) {
              flagRemoteError(err);
              throw err;
            }
          };

          const issueTokens = (username, cache) => {
            const expiresAt = Date.now() + SESSION_TOKEN_TTL_MS;
            const token = `token-${username}-${crypto.randomUUID()}`;
            const refreshToken = `refresh-${username}-${crypto.randomUUID()}`;
            cache.sessionTokens = { username, token, refreshToken, expiresAt };
            storage.save(REMOTE_BACKUP_KEY, cache);
            return cache.sessionTokens;
          };

          return {
            fetchSnapshot: () => request('snapshot'),
            pushSnapshot: (payload) => request('snapshot', { method: 'PUT', body: payload }),
            pushUsers: (users) => request('users', { method: 'PUT', body: users }),
            pushVideos: (videos) => request('videos', { method: 'PUT', body: videos }),
            pushWatchLater: (list) => request('watch-later', { method: 'PUT', body: list }),
            pushPlaylists: (list) => request('playlists', { method: 'PUT', body: list }),
            pushHistorico: (list) => request('historico', { method: 'PUT', body: list }),
            pushComments: (comments) => request('comments', { method: 'PUT', body: comments }),
            pushTranscripts: (transcripts) => request('transcripts', { method: 'PUT', body: transcripts }),
            pushMeta: (meta) => request('meta', { method: 'PUT', body: meta }),
            pushSession: (session) => request('session', { method: 'POST', body: session }),
            loginSession: (payload) => request('session/login', { method: 'POST', body: payload }),
            refreshSession: (payload) => request('session/refresh', { method: 'POST', body: payload }),
            logoutSession: () => request('session/logout', { method: 'POST' }),
          };
        }

      const remoteApi = createRemoteApi();
      const remoteQueue = [];
      let remoteSyncing = false;

      async function processRemoteQueue() {
        if (remoteSyncing || !remoteState.online) return;
        remoteSyncing = true;
        while (remoteQueue.length) {
          const job = remoteQueue[0];
          try {
            if (job.type === 'snapshot') await remoteApi.pushSnapshot(job.payload);
            if (job.type === 'users') await remoteApi.pushUsers(job.payload);
            if (job.type === 'videos') await remoteApi.pushVideos(job.payload);
            if (job.type === 'watchLater') await remoteApi.pushWatchLater(job.payload);
            if (job.type === 'playlists') await remoteApi.pushPlaylists(job.payload);
            if (job.type === 'historico') await remoteApi.pushHistorico(job.payload);
            if (job.type === 'comments') await remoteApi.pushComments(job.payload);
            if (job.type === 'transcripts') await remoteApi.pushTranscripts(job.payload);
            if (job.type === 'meta') await remoteApi.pushMeta(job.payload);
            if (job.type === 'session') await remoteApi.pushSession(job.payload);
            remoteQueue.shift();
          } catch (err) {
            job.attempts = (job.attempts || 0) + 1;
            console.warn('Retry de sync remoto', job.type, job.attempts, err);
            if (!remoteState.online) {
              showToast('Backend offline: sincroniza√ß√£o pausada.');
              break;
            }
            if (job.attempts >= 3) {
              remoteQueue.shift();
              showToast('N√£o foi poss√≠vel sincronizar com o servidor agora.');
            } else {
              await wait(400 * job.attempts);
            }
          }
        }
        remoteSyncing = false;
      }

      function enqueueRemoteSync(type, payload) {
        remoteQueue.push({ type, payload, attempts: 0 });
        processRemoteQueue();
      }

      function supportsSubtleCrypto() {
        try { return !!(window.crypto && crypto.subtle && crypto.subtle.digest); } catch { return false; }
      }

      function logSecuritySupport() {
        console.info(`Suporte a crypto.subtle: ${securitySupport.subtleAvailable ? 'ativo' : 'indispon√≠vel; fallback ser√° usado se necess√°rio.'}`);
      }

      function sha256Fallback(message) {
        // Implementa√ß√£o s√≠ncrona m√≠nima de SHA-256 para contextos sem Web Crypto.
        const rightRotate = (value, amount) => (value >>> amount) | (value << (32 - amount));
        const mathPow = Math.pow;
        const maxWord = mathPow(2, 32);
        let result = '';
        const words = [];
        const asciiBitLength = message.length * 8;
        const hash = [];
        const k = [];
        let primeCounter = 0;

        const isPrime = (n) => {
          const sqrtN = Math.sqrt(n);
          for (let factor = 2; factor <= sqrtN; factor++) {
            if (n % factor === 0) return false;
          }
          return true;
        };

        for (let candidate = 2; primeCounter < 64; candidate++) {
          if (!isPrime(candidate)) continue;
          if (primeCounter < 8) {
            hash[primeCounter] = (mathPow(candidate, 1 / 2) * maxWord) | 0;
          }
          k[primeCounter] = (mathPow(candidate, 1 / 3) * maxWord) | 0;
          primeCounter++;
        }

        message += '\x80';
        while ((message.length % 64) - 56) message += '\x00';
        for (let i = 0; i < message.length; i++) {
          const j = message.charCodeAt(i);
          if (j >> 8) throw new Error('Caractere fora do ASCII na hash fallback.');
          words[i >> 2] |= j << ((3 - (i % 4)) * 8);
        }

        words[words.length] = (asciiBitLength / maxWord) | 0;
        words[words.length] = asciiBitLength;

        for (let j = 0; j < words.length;) {
          const w = words.slice(j, j += 16);
          const oldHash = hash.slice(0);

          for (let i = 0; i < 64; i++) {
            const w15 = w[i - 15], w2 = w[i - 2];
            w[i] = (i < 16) ? w[i] : (w[i - 16] + (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ (w15 >>> 3)) + w[i - 7] + (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ (w2 >>> 10))) | 0;
            const temp1 = (hash[7] + (rightRotate(hash[4], 6) ^ rightRotate(hash[4], 11) ^ rightRotate(hash[4], 25)) + ((hash[4] & hash[5]) ^ (~hash[4] & hash[6])) + k[i] + w[i]) | 0;
            const temp2 = (rightRotate(hash[0], 2) ^ rightRotate(hash[0], 13) ^ rightRotate(hash[0], 22)) + ((hash[0] & hash[1]) ^ (hash[0] & hash[2]) ^ (hash[1] & hash[2]));
            hash[7] = hash[6];
            hash[6] = hash[5];
            hash[5] = hash[4];
            hash[4] = (hash[3] + temp1) | 0;
            hash[3] = hash[2];
            hash[2] = hash[1];
            hash[1] = hash[0];
            hash[0] = (temp1 + temp2) | 0;
          }

          for (let i = 0; i < 8; i++) hash[i] = (hash[i] + oldHash[i]) | 0;
        }

        for (let i = 0; i < 8; i++) {
          for (let j = 3; j + 1; j--) {
            const b = (hash[i] >> (j * 8)) & 255;
            result += ((b < 16) ? 0 : '') + b.toString(16);
          }
        }
        return result;
      }

      async function sha256(text) {
        try {
          if (securitySupport.subtleAvailable) {
            const enc = new TextEncoder().encode(text);
            const hashBuffer = await crypto.subtle.digest('SHA-256', enc);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
          }
        } catch (err) {
          console.warn('Hash com crypto.subtle falhou; tentando fallback s√≠ncrono.', err);
        }

        try {
          securitySupport.fallbackUsed = true;
          const hash = sha256Fallback(text);
          console.info('Hash gerado com fallback s√≠ncrono por aus√™ncia de Web Crypto.');
          return hash;
        } catch (err) {
          console.error('Fallback de hash indispon√≠vel.', err);
          showToast('N√£o foi poss√≠vel gerar o hash da senha neste navegador. Tente em um ambiente seguro.');
          throw err;
        }
      }

      logSecuritySupport();

      function loadSessionTokens() {
        try { return JSON.parse(sessionStorage.getItem(SESSION_TOKEN_KEY)) || null; } catch { return null; }
      }

      function persistSessionTokens(tokens) {
        state.sessionTokens = tokens;
        if (!tokens) {
          sessionStorage.removeItem(SESSION_TOKEN_KEY);
          return;
        }
        sessionStorage.setItem(SESSION_TOKEN_KEY, JSON.stringify(tokens));
      }

    const sharedInitial = migrateLegacyStores();
    const baseUsers = sharedInitial?.users ?? storage.load('mtube-users', []);
    const baseVideos = sharedInitial?.videos ?? storage.load('mtube-videos', []);
    const baseWatchLater = sharedInitial?.watchLater ?? storage.load(WATCH_LATER_KEY, []);
    const basePlaylists = sharedInitial?.playlists ?? storage.load(PLAYLIST_KEY, []);
    const baseHistorico = sharedInitial?.historico ?? storage.load(HISTORY_KEY, []);
    const baseComments = sharedInitial?.comments ?? storage.load(COMMENT_KEY, {});
    const baseTranscripts = sharedInitial?.transcripts ?? storage.load(TRANSCRIPT_KEY, {});
    const baseSubscriptions = sharedInitial?.subscriptions ?? storage.load(SUBSCRIPTIONS_KEY, []);
    const baseMeta = sharedInitial?.meta ?? storage.load(META_KEY, defaultMeta());
    const baseAutoplay = storage.load(AUTOPLAY_KEY, true);
    const baseSettings = storage.load(SETTINGS_KEY, defaultSettings());

    // Estado
      const state = {
        user: null,
        users: baseUsers,
        session: storage.load('mtube-session', null),
        sessionTokens: loadSessionTokens(),
        videos: baseVideos,
      clips: storage.load('mtube-clips', [
        { id: 'clip-1', title: 'Clip r√°pido', duration: '0:30', views: 1200, thumb: 'https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?auto=format&fit=crop&w=600&q=60' }
      ]),
      filter: { categoria: 'all', ordem: 'recentes', duracao: 'todas', afinidade: true },
      pagination: { page: 1, perPage: 12 },
      search: { termo: '', resultados: [], indice: 0 },
      afinidade: { categorias: {} },
      currentVideo: null,
      comments: baseComments,
      channelView: { tab: 'inicio', key: null },
      notifications: { items: [], lastSeen: 0, unread: 0 },
      watchLater: baseWatchLater,
      watchLaterFilter: { categoria: 'all', ordem: 'recentes' },
      playlists: basePlaylists,
      playlistsFilter: { categoria: 'all', ordem: 'recentes' },
      historico: baseHistorico,
      historicoFilter: { categoria: 'all', ordem: 'recentes' },
      transcripts: baseTranscripts,
      transcriptSearch: '',
      player: { duration: 0, position: 0, playing: false, volume: 0.8 },
      subscriptions: baseSubscriptions,
      meta: baseMeta,
      autoplay: baseAutoplay,
      settings: baseSettings,
    };

    const defaultThumbs = [
      'https://images.unsplash.com/photo-1525182008055-f88b95ff7980?auto=format&fit=crop&w=800&q=60',
      'https://images.unsplash.com/photo-1504384308090-c894fdcc538d?auto=format&fit=crop&w=800&q=60',
      'https://images.unsplash.com/photo-1511671782779-c97d3d27a1d4?auto=format&fit=crop&w=800&q=60',
      'https://images.unsplash.com/photo-1507525428034-b723cf961d3e?auto=format&fit=crop&w=800&q=60'
    ];

    const defaultAvatars = [
      'https://images.unsplash.com/photo-1502685104226-ee32379fefbe?auto=format&fit=crop&w=300&q=60',
      'https://images.unsplash.com/photo-1487412720507-e7ab37603c6f?auto=format&fit=crop&w=300&q=60',
      'https://images.unsplash.com/photo-1500648767791-00dcc994a43e?auto=format&fit=crop&w=300&q=60',
      'https://images.unsplash.com/photo-1504595403659-9088ce801e29?auto=format&fit=crop&w=300&q=60',
      'https://images.unsplash.com/photo-1442458017215-285b83f65851?auto=format&fit=crop&w=300&q=60',
      'https://images.unsplash.com/photo-1527980965255-d3b416303d12?auto=format&fit=crop&w=300&q=60'
    ];

    function getUserByUsername(username) {
      return state.users.find(u => u.username === username) || null;
    }

    function matchUserByChannel(channel) {
      if (!channel) return null;
      return state.users.find(u => u.display === channel || u.username === channel) || null;
    }

    function avatarInfo({ username, channel }) {
      const user = username ? getUserByUsername(username) : matchUserByChannel(channel);
      const name = user?.display || channel || username || 'Usu√°rio';
      return {
        url: user?.avatar || '',
        initials: (name || 'U').charAt(0).toUpperCase(),
        name,
      };
    }

    function avatarTemplate(info) {
      if (info.url) {
        return `<div class="avatar img" aria-label="Avatar de ${escapeHTML(info.name)}"><img src="${info.url}" alt="Avatar de ${escapeHTML(info.name)}"></div>`;
      }
      return `<div class="avatar" aria-label="Avatar de ${escapeHTML(info.name)}">${info.initials}</div>`;
    }

    function vincularAutores() {
      state.videos = state.videos.map(video => {
        if (video.owner) return video;
        const match = matchUserByChannel(video.channel);
        return match ? { ...video, owner: match.username } : video;
      });
    }

    // Notifica√ß√µes: persist√™ncia local por usu√°rio e badge de n√£o lidas
    function getNotifStorageKey(username = state.user?.username) {
      return username ? `${NOTIF_KEY}-${username}` : NOTIF_KEY;
    }

    function normalizeNotifications(payload = {}) {
      return {
        items: Array.isArray(payload.items) ? payload.items : [],
        lastSeen: Number(payload.lastSeen || 0),
      };
    }

    function loadNotifications(username) {
      return normalizeNotifications(storage.load(getNotifStorageKey(username), { items: [], lastSeen: 0 }));
    }

    function saveNotifications() {
      if (!state.user) return;
      const payload = { items: state.notifications.items, lastSeen: state.notifications.lastSeen };
      storage.save(getNotifStorageKey(), payload);
    }

    function countUnreadNotifications(items = []) {
      return items.filter(item => !item.read).length;
    }

    function renderNotificationUI() {
      const badge = qs('#notif-badge');
      const list = qs('#notif-list');
      const empty = qs('#notif-empty');
      if (!badge || !list || !empty) return;
      const unread = state.notifications.unread || 0;
      badge.textContent = unread > 0 ? String(unread) : '';
      badge.style.display = unread > 0 ? 'inline-block' : 'none';

      list.innerHTML = '';
      const items = state.notifications.items || [];
      if (!items.length) {
        empty.classList.remove('hidden');
        return;
      }
      empty.classList.add('hidden');
      items.slice(0, 20).forEach(item => {
        const entry = document.createElement('div');
        entry.className = `notif-item ${item.read ? '' : 'notif-unread'}`;
        entry.dataset.videoId = item.videoId;
        entry.dataset.notifId = item.id;
        entry.innerHTML = `
          <img class="notif-thumb" src="${item.thumb}" alt="Miniatura da notifica√ß√£o">
          <div>
            <strong>${escapeHTML(item.title)}</strong>
            <div class="notif-meta">${escapeHTML(item.channel)} ¬∑ ${timeAgo(item.createdAt)}</div>
          </div>
        `;
        list.appendChild(entry);
      });
    }

    function hydrateNotifications() {
      if (!state.user) {
        state.notifications = { items: [], lastSeen: 0, unread: 0 };
        renderNotificationUI();
        return;
      }
      const payload = loadNotifications(state.user.username);
      state.notifications = { ...payload, unread: countUnreadNotifications(payload.items) };
      refreshNotifications({ silent: true });
    }

    function refreshNotifications({ silent = false } = {}) {
      if (!state.user) return;
      const payload = loadNotifications(state.user.username);
      const lastSeen = payload.lastSeen || 0;
      let items = payload.items || [];
      const subscribedKeys = state.subscriptions || [];
      const novosVideos = state.videos
        .filter(video => {
          const channelKey = getChannelKeyFromVideo(video);
          const matchSubscription = !subscribedKeys.length || subscribedKeys.includes(channelKey);
          return (video.createdAt || 0) > lastSeen && video.owner !== state.user.username && matchSubscription;
        })
        .sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));

      if (novosVideos.length) {
        novosVideos.forEach(video => {
          if (items.some(item => item.videoId === video.id)) return;
          items.unshift({
            id: `notif-${video.id}`,
            videoId: video.id,
            title: video.title,
            channel: video.channel,
            thumb: video.thumb,
            createdAt: video.createdAt || Date.now(),
            read: false,
          });
        });
        items = items.slice(0, 50);
        state.notifications = {
          items,
          lastSeen: payload.lastSeen,
          unread: countUnreadNotifications(items),
        };
        saveNotifications();
        if (!silent) showToast('Novas notifica√ß√µes dispon√≠veis.');
      } else {
        state.notifications = { ...payload, unread: countUnreadNotifications(items) };
      }
      renderNotificationUI();
    }

    function markNotificationsRead({ updateLastSeen = true } = {}) {
      if (!state.user) return;
      const items = (state.notifications.items || []).map(item => ({ ...item, read: true }));
      state.notifications = {
        items,
        lastSeen: updateLastSeen ? Date.now() : state.notifications.lastSeen,
        unread: 0,
      };
      saveNotifications();
      renderNotificationUI();
    }

    function getChannelInfo({ username, channel }) {
      const user = username ? getUserByUsername(username) : matchUserByChannel(channel);
      const name = user?.display || channel || username || 'Canal';
      const key = user?.username || channel || username || 'canal';
      return {
        key,
        name,
        avatar: user?.avatar || '',
        description: user?.bio || `Canal de ${name} no MTube.`,
      };
    }

    function getChannelVideos(info) {
      return state.videos.filter(video => (
        (info.key && video.owner === info.key) ||
        (video.channel && video.channel === info.name)
      ));
    }

    function getChannelKeyFromVideo(video) {
      return video?.owner || video?.channel || '';
    }

    function isSubscribedChannel(channelKey) {
      return state.subscriptions.some(key => String(key) === String(channelKey));
    }

    function getSharedPayload() {
      return {
        users: state.users,
        videos: state.videos,
        watchLater: state.watchLater,
        playlists: state.playlists,
        historico: state.historico,
        comments: state.comments,
        transcripts: state.transcripts,
        subscriptions: state.subscriptions,
        meta: state.meta,
      };
    }

      function markDatasetUpdated(key, { skipSave = false } = {}) {
        state.meta[key] = Date.now();
        if (!skipSave) storage.save(META_KEY, state.meta);
      }

      function mergeIdLists(local = [], remote = []) {
        const seen = new Set();
        const merged = [];
        [...remote, ...local].forEach(id => {
          if (id === undefined || id === null) return;
          const key = String(id);
          if (seen.has(key)) return;
          seen.add(key);
          merged.push(id);
        });
        return merged;
      }

      function mergeComments(local = {}, remote = {}) {
        const result = {};
        const ids = new Set([...Object.keys(local), ...Object.keys(remote)]);
        ids.forEach(videoId => {
          const map = new Map();
          (remote[videoId] || []).forEach(c => c?.id && map.set(c.id, c));
          (local[videoId] || []).forEach(c => {
            if (!c?.id) return;
            const existing = map.get(c.id);
            if (!existing) { map.set(c.id, c); return; }
            const currentTs = c.updatedAt || c.createdAt || 0;
            const remoteTs = existing.updatedAt || existing.createdAt || 0;
            map.set(c.id, currentTs >= remoteTs ? c : existing);
          });
          const merged = Array.from(map.values()).sort((a,b) => (b.createdAt || 0) - (a.createdAt || 0));
          if (merged.length) result[videoId] = merged;
        });
        return result;
      }

      function mergeTranscripts(local = {}, remote = {}) {
        const result = {};
        const ids = new Set([...Object.keys(local), ...Object.keys(remote)]);
        ids.forEach(videoId => {
          const map = new Map();
          (remote[videoId] || []).forEach(t => t?.id && map.set(t.id, t));
          (local[videoId] || []).forEach(t => {
            if (!t?.id) return;
            const existing = map.get(t.id);
            if (!existing) { map.set(t.id, t); return; }
            const currentTs = t.updatedAt || 0;
            const remoteTs = existing.updatedAt || 0;
            map.set(t.id, currentTs >= remoteTs ? t : existing);
          });
          const merged = Array.from(map.values()).sort((a,b) => (a.time || 0) - (b.time || 0));
          if (merged.length) result[videoId] = merged;
        });
        return result;
      }

      function resolveDataset({ local, remote, key, merger }) {
        const localMeta = state.meta?.[key] || 0;
        const remoteMeta = (remote?.meta?.[key]) || 0;
        if (remoteMeta > localMeta) {
          state.meta[key] = remoteMeta;
          return { value: remote[key] ?? local, changed: true, fromRemote: true };
        }
        if (localMeta > remoteMeta) return { value: local, changed: false, fromRemote: false };
        const merged = merger ? merger(local, remote[key]) : (remote[key] ?? local);
        const changed = merged !== local;
        if (changed) state.meta[key] = Date.now();
        return { value: merged, changed, fromRemote: changed && !!remote[key] };
      }

      function persistSharedState({ datasets = [], skipRemoteSync = false } = {}) {
        datasets.forEach(ds => markDatasetUpdated(ds, { skipSave: true }));
        storage.save('mtube-users', state.users);
        storage.save('mtube-videos', state.videos);
        storage.save(WATCH_LATER_KEY, state.watchLater);
        storage.save(PLAYLIST_KEY, state.playlists);
        storage.save(HISTORY_KEY, state.historico);
        storage.save(COMMENT_KEY, state.comments);
        storage.save(TRANSCRIPT_KEY, state.transcripts);
        storage.save(SUBSCRIPTIONS_KEY, state.subscriptions);
        storage.save(META_KEY, state.meta);
        saveSharedStore(getSharedPayload());
        remoteBackup.save(getSharedPayload());
        if (!skipRemoteSync && remoteState.online) {
          datasets.forEach(ds => enqueueRemoteSync(ds, state[ds]));
          enqueueRemoteSync('meta', state.meta);
        } else if (!remoteState.online && datasets.length) {
          console.warn('Sincroniza√ß√£o remota inativa; dados mantidos apenas localmente.');
        }
      }

      function applySharedPayload(payload, { skipRender = false } = {}) {
        if (!payload) return;
        const beforeMeta = { ...state.meta };
        const mergedFlags = [];
        const resUsers = resolveDataset({ local: state.users, remote: payload, key: 'users', merger: mergeCollections });
        state.users = resUsers.value; mergedFlags.push(resUsers);
        const resVideos = resolveDataset({ local: state.videos, remote: payload, key: 'videos', merger: mergeCollections });
        state.videos = resVideos.value; mergedFlags.push(resVideos);
        const resWatch = resolveDataset({ local: state.watchLater, remote: payload, key: 'watchLater', merger: mergeIdLists });
        state.watchLater = resWatch.value; mergedFlags.push(resWatch);
        const resPlay = resolveDataset({ local: state.playlists, remote: payload, key: 'playlists', merger: mergeIdLists });
        state.playlists = resPlay.value; mergedFlags.push(resPlay);
        const resHist = resolveDataset({ local: state.historico, remote: payload, key: 'historico', merger: mergeIdLists });
        state.historico = resHist.value; mergedFlags.push(resHist);
        const resComments = resolveDataset({ local: state.comments, remote: payload, key: 'comments', merger: mergeComments });
        state.comments = resComments.value; mergedFlags.push(resComments);
        const resTranscript = resolveDataset({ local: state.transcripts, remote: payload, key: 'transcripts', merger: mergeTranscripts });
        state.transcripts = resTranscript.value; mergedFlags.push(resTranscript);
        const resSubscriptions = resolveDataset({ local: state.subscriptions, remote: payload, key: 'subscriptions', merger: mergeIdLists });
        state.subscriptions = resSubscriptions.value; mergedFlags.push(resSubscriptions);
        vincularAutores();
        if (state.user) {
          const refreshed = state.users.find(u => u.username === state.user.username);
          if (refreshed) {
            state.user = { ...state.user, ...refreshed };
            renderUserChip(state.user);
          }
        }
        storage.save('mtube-users', state.users);
        storage.save('mtube-videos', state.videos);
        storage.save(WATCH_LATER_KEY, state.watchLater);
        storage.save(PLAYLIST_KEY, state.playlists);
        storage.save(HISTORY_KEY, state.historico);
        storage.save(COMMENT_KEY, state.comments);
        storage.save(TRANSCRIPT_KEY, state.transcripts);
        storage.save(SUBSCRIPTIONS_KEY, state.subscriptions);
        storage.save(META_KEY, state.meta);
        atualizarAfinidade();
        const mergedMeta = JSON.stringify(beforeMeta) !== JSON.stringify(state.meta);
        const mergedRemote = mergedFlags.some(f => f.fromRemote);
        if (!skipRender) {
          renderGrid();
          renderClips();
          renderWatchLater();
          renderPlaylists();
          renderHistorico();
          renderSubscriptions();
          if (state.currentVideo) openWatch(state.currentVideo.id, { skipViewIncrement: true, skipHistory: true });
        }
        return { mergedMeta, mergedRemote, anyChange: mergedFlags.some(f => f.changed) };
      }

      async function syncFromRemote({ silent = false } = {}) {
        try {
          const snapshot = await remoteApi.fetchSnapshot();
          if (!snapshot) return;
          const result = applySharedPayload(snapshot, { skipRender: true });
          persistSharedState({ skipRemoteSync: true });
          renderGrid();
          renderClips();
          renderWatchLater();
          renderPlaylists();
          renderHistorico();
          renderSubscriptions();
          if (state.currentVideo) openWatch(state.currentVideo.id, { skipViewIncrement: true, skipHistory: true });
          if (!silent && result?.anyChange) {
            const msg = result.mergedRemote ? 'Dados remotos mesclados e sincronizados.' : 'Dados locais mantidos e sincronizados.';
            showToast(msg);
          }
        } catch (err) {
          console.warn('Falha ao sincronizar com backend remoto', err);
          const backup = remoteBackup.load();
          if (backup) {
            applySharedPayload(backup, { skipRender: true });
            renderGrid();
            renderClips();
            renderWatchLater();
            renderPlaylists();
            renderHistorico();
            renderSubscriptions();
            if (state.currentVideo) openWatch(state.currentVideo.id);
            if (!silent) showToast('Usando cache local; sincroniza√ß√£o remota indispon√≠vel.');
          } else if (!silent) {
            showToast('N√£o foi poss√≠vel buscar dados remotos agora.');
          }
        }
      }

    function ensureSeedVideos() {
      const shared = loadSharedStore();
      if (shared?.videos?.length) {
        applySharedPayload(shared, { skipRender: true });
        return;
      }
      if (state.videos.length) {
        persistSharedState({ datasets: ['videos', 'users'] });
        return;
      }
      const now = Date.now();
      state.videos = [
        {
          id: 'v-1',
          title: 'Bem-vindo ao MTube',
          description: 'Apresenta√ß√£o r√°pida da nova experi√™ncia inspirada no YouTube.\n00:00 Introdu√ß√£o\n01:00 Navega√ß√£o principal\n02:30 Upload guiado\n03:30 Encerramento',
          owner: 'mtube-team',
          channel: 'Equipe MTube',
          category: 'Entretenimento',
          duration: 4,
          thumb: defaultThumbs[0],
          views: 1200,
          likes: 340,
          dislikes: 12,
          createdAt: now - 1000 * 60 * 60 * 3,
        },
        {
          id: 'v-2',
          title: 'Como publicar v√≠deos',
          description: 'Passo a passo do fluxo de upload e organiza√ß√£o de categorias.\n00:00 Acesso ao upload\n01:10 Escolha de miniatura\n03:00 Publica√ß√£o e feed',
          owner: 'mtube-team',
          channel: 'Equipe MTube',
          category: 'Games',
          duration: 6,
          thumb: defaultThumbs[1],
          views: 980,
          likes: 280,
          dislikes: 6,
          createdAt: now - 1000 * 60 * 60 * 8,
        }
      ];
      if (!state.users.find(u => u.username === 'mtube-team')) {
        state.users.push({ username: 'mtube-team', password: 'seed', display: 'Equipe MTube', avatar: defaultAvatars[0] });
      }
      vincularAutores();
      persistSharedState({ datasets: ['videos', 'users'] });
    }

    function atualizarAfinidade() {
      const categorias = {};
      const acumular = (cat, peso = 1) => {
        if (!cat) return;
        categorias[cat] = (categorias[cat] || 0) + peso;
      };
      state.videos.forEach(v => acumular(v.category, Math.max(1, Math.min(5, (v.views || 0) / 500))));
      state.watchLater.forEach(id => {
        const v = state.videos.find(x => x.id === id);
        if (v) acumular(v.category, 4);
      });
      state.playlists.forEach(id => {
        const v = state.videos.find(x => x.id === id);
        if (v) acumular(v.category, 3);
      });
      state.historico.forEach(id => {
        const v = state.videos.find(x => x.id === id);
        if (v) acumular(v.category, 5);
      });
      state.clips.forEach(c => acumular(c.category, 2));
      state.afinidade.categorias = categorias;
    }

    function pontuarAfinidade(video) {
      return (state.afinidade.categorias?.[video.category] || 0);
    }

    // Renderiza√ß√£o
    function minutesToDuration(min) {
      const m = Math.floor(min);
      const s = Math.round((min - m) * 60);
      return `${m}:${s.toString().padStart(2,'0')}`;
    }

    function timeAgo(ts) {
      const diff = Date.now() - ts;
      const hours = Math.floor(diff / 3.6e6);
      if (hours < 1) return 'agora mesmo';
      if (hours < 24) return `${hours}h atr√°s`;
      const days = Math.floor(hours / 24);
      return `${days}d atr√°s`;
    }

    function secondsToClock(sec) {
      const total = Math.max(0, Math.floor(sec));
      const h = Math.floor(total / 3600);
      const m = Math.floor((total % 3600) / 60);
      const s = total % 60;
      const base = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
      return h > 0 ? `${h}:${base}` : base;
    }

    function parseTimecode(str) {
      if (!str) return null;
      const parts = str.split(':').map(Number);
      if (parts.some(isNaN)) return null;
      if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
      if (parts.length === 2) return parts[0] * 60 + parts[1];
      return null;
    }

      window.addEventListener('storage', (ev) => {
        if (ev.key !== SHARED_KEY || !ev.newValue) return;
        try {
          applySharedPayload(JSON.parse(ev.newValue));
        } catch (err) {
          console.warn('Falha ao sincronizar storage compartilhado', err);
        }
      });

      sharedChannel?.addEventListener('message', ({ data }) => {
        if (data?.type === 'sync') applySharedPayload(data.payload);
      });

      document.addEventListener('visibilitychange', () => {
        if (!document.hidden) syncFromRemote({ silent: true });
      });

    function escapeHTML(str = '') {
      return str.replace(/[&<>"']/g, (ch) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[ch]));
    }

    function highlightTerm(text = '', term = '') {
      if (!term) return escapeHTML(text);
      const safeTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const regex = new RegExp(`(${safeTerm})`, 'gi');
      return escapeHTML(text).replace(regex, '<mark>$1</mark>');
    }

    function parseChapters(description) {
      if (!description) return [];
      const lines = description.split(/\n|;/).map(l => l.trim()).filter(Boolean);
      const chapters = [];
      const regex = /(\d{1,2}:\d{2}(?::\d{2})?)\s+(.+)/;
      lines.forEach(line => {
        const match = line.match(regex);
        if (!match) return;
        const time = parseTimecode(match[1]);
        if (time === null) return;
        chapters.push({ time, label: match[2] });
      });
      return chapters.sort((a,b) => a.time - b.time);
    }

    function persistTranscripts() {
      persistSharedState({ datasets: ['transcripts'] });
    }

    function getTranscript(video) {
      if (!video) return [];
      if (!state.transcripts[video.id]) {
        const sentences = video.description.split(/\.|\n|;/).map(t => t.trim()).filter(Boolean);
        const fallback = ['Introdu√ß√£o', 'Conte√∫do principal', 'Resumo', 'Encerramento'];
        const totalSeconds = Math.max(60, Math.round((video.duration || 1) * 60));
        const baseList = sentences.length ? sentences : fallback;
        const step = Math.max(10, Math.floor(totalSeconds / Math.max(1, baseList.length)));
        const updatedAt = Date.now();
        let cursor = 0;
        state.transcripts[video.id] = baseList.map((text, idx) => {
          const item = { id: `t-${idx}`, time: Math.min(cursor, totalSeconds), text: text || `Se√ß√£o ${idx + 1}`, updatedAt };
          cursor += step;
          return item;
        });
        state.transcripts[video.id].sort((a,b) => a.time - b.time);
        persistTranscripts();
      }
      return state.transcripts[video.id];
    }

    // Coment√°rios
    const commentCooldown = {};

    function sanitizeText(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function persistComments() {
      persistSharedState({ datasets: ['comments'] });
    }

    function getComments(videoId) {
      return state.comments[videoId] || [];
    }

    function renderComments(videoId) {
      const list = qs('#comments-list');
      const comments = getComments(videoId);
      if (!list) return;
      list.innerHTML = '';
      if (!comments.length) {
        list.innerHTML = '<p style="color: var(--muted);">Nenhum coment√°rio ainda. Seja o primeiro!</p>';
        return;
      }
      comments.forEach(comment => {
        const ocultadoParaUsuario = state.user && comment.reportedBy?.includes(state.user.username);
        const wrap = document.createElement('div');
        const userReaction = state.user ? (comment.reactions?.[state.user.username] || null) : null;
        wrap.className = 'comment-item';

        if (ocultadoParaUsuario) {
          wrap.innerHTML = `
            <div class="comment-head">
              <strong>${comment.author}</strong>
              <span>Coment√°rio ocultado ap√≥s den√∫ncia</span>
            </div>
          `;
          list.appendChild(wrap);
          return;
        }

        const head = document.createElement('div');
        head.className = 'comment-head';
        const info = avatarInfo({ username: comment.username, channel: comment.author });
        const reports = comment.reportedBy?.length ? ` ¬∑ ${comment.reportedBy.length} den√∫ncia(s)` : '';
        head.innerHTML = `
          ${avatarTemplate(info)}
          <div style="display:flex;flex-direction:column;gap:2px;">
            <strong>${escapeHTML(comment.author)}</strong>
            <span>${timeAgo(comment.createdAt)}${reports}</span>
          </div>
        `;

        const body = document.createElement('div');
        body.textContent = comment.text;

        const actions = document.createElement('div');
        actions.className = 'comment-actions';
        const likeBtn = document.createElement('button');
        likeBtn.dataset.commentAction = 'like';
        likeBtn.dataset.id = comment.id;
        likeBtn.className = userReaction === 'like' ? 'active' : '';
        likeBtn.textContent = `Curtir (${comment.likes || 0})`;

        const dislikeBtn = document.createElement('button');
        dislikeBtn.dataset.commentAction = 'dislike';
        dislikeBtn.dataset.id = comment.id;
        dislikeBtn.className = userReaction === 'dislike' ? 'active' : '';
        dislikeBtn.textContent = `N√£o curtir (${comment.dislikes || 0})`;

        const reportBtn = document.createElement('button');
        reportBtn.dataset.commentAction = 'report';
        reportBtn.dataset.id = comment.id;
        reportBtn.textContent = comment.reportedBy?.length ? `Denunciar (${comment.reportedBy.length})` : 'Denunciar';

        actions.append(likeBtn, dislikeBtn, reportBtn);

        wrap.append(head, body, actions);
        list.appendChild(wrap);
      });
    }

    async function addComment(videoId, text) {
      if (!state.user) {
        showToast('Fa√ßa login para comentar.');
        return;
      }
      const trimmed = text.trim();
      if (!trimmed) return showToast('N√£o √© poss√≠vel enviar um coment√°rio vazio.');
      const now = Date.now();
      const ultimoEnvio = commentCooldown[state.user.username] || 0;
      if (now - ultimoEnvio < COMMENT_COOLDOWN_MS) {
        return showToast('Aguarde alguns segundos antes de comentar novamente.');
      }
      if (!state.comments[videoId]) state.comments[videoId] = [];
      const jaExiste = state.comments[videoId].some(c => c.username === state.user.username && (c.rawText || c.text)?.toLowerCase() === trimmed.toLowerCase());
      if (jaExiste) return showToast('Voc√™ j√° enviou esse coment√°rio.');

      const safeText = sanitizeText(trimmed);
      const comment = {
        id: 'c-' + crypto.randomUUID(),
        author: state.user.display || state.user.username,
        username: state.user.username,
        text: safeText,
        rawText: trimmed,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        likes: 0,
        dislikes: 0,
        reactions: {},
        reportedBy: [],
      };
      state.comments[videoId].unshift(comment);
      commentCooldown[state.user.username] = now;
      persistComments();
      renderComments(videoId);
      showToast('Coment√°rio publicado.');
    }

    function reactToComment(commentId, action) {
      if (!state.user || !state.currentVideo) {
        showToast('Entre na sua conta para reagir.');
        return;
      }
      const comments = getComments(state.currentVideo.id);
      const comment = comments.find(c => c.id === commentId);
      if (!comment) return;
      comment.reactions = comment.reactions || {};
      const previous = comment.reactions[state.user.username];
      // Reverte rea√ß√£o anterior, se houver
      if (previous === 'like') comment.likes = Math.max(0, (comment.likes || 0) - 1);
      if (previous === 'dislike') comment.dislikes = Math.max(0, (comment.dislikes || 0) - 1);

      if (previous === action) {
        delete comment.reactions[state.user.username];
        comment.updatedAt = Date.now();
        persistComments();
        renderComments(state.currentVideo.id);
        return;
      }

      comment.reactions[state.user.username] = action;
      if (action === 'like') comment.likes = (comment.likes || 0) + 1;
      if (action === 'dislike') comment.dislikes = (comment.dislikes || 0) + 1;
      comment.updatedAt = Date.now();
      persistComments();
      renderComments(state.currentVideo.id);
    }

    function reportComment(commentId) {
      if (!state.user || !state.currentVideo) {
        showToast('Entre na sua conta para denunciar.');
        return;
      }
      const comments = getComments(state.currentVideo.id);
      const comment = comments.find(c => c.id === commentId);
      if (!comment) return;
      comment.reportedBy = comment.reportedBy || [];
      if (comment.reportedBy.includes(state.user.username)) {
        showToast('Voc√™ j√° denunciou este coment√°rio.');
        return;
      }
      comment.reportedBy.push(state.user.username);
      comment.updatedAt = Date.now();
      persistComments();
      renderComments(state.currentVideo.id);
      showToast('Coment√°rio denunciado e ocultado localmente.');
    }

    // Cap√≠tulos e transcri√ß√£o
    function renderChapters(video) {
      const list = qs('#chapters-list');
      const summary = qs('#chapters-summary');
      if (!list || !summary) return;
      list.innerHTML = '';
      const chapters = parseChapters(video.description);
      if (!chapters.length) {
        summary.textContent = 'Sem marcadores na descri√ß√£o deste v√≠deo.';
        list.innerHTML = '<p style="color: var(--muted);">Adicione timestamps como "00:00 Intro" na descri√ß√£o para gerar cap√≠tulos.</p>';
        return;
      }
      summary.textContent = `${chapters.length} cap√≠tulo(s) a partir da descri√ß√£o.`;
      chapters.forEach(ch => {
        const btn = document.createElement('button');
        btn.className = 'chapter-link';
        btn.innerHTML = `<span class="chapter-time">${secondsToClock(ch.time)}</span><span>${ch.label}</span>`;
        btn.addEventListener('click', () => setPlayerPosition(ch.time, true));
        list.appendChild(btn);
      });
    }

    function highlightTranscriptByTime(time) {
      const list = qs('#transcript-list');
      if (!list) return;
      const items = Array.from(list.querySelectorAll('.transcript-item'));
      if (!items.length) return;
      let active = items[0];
      items.forEach(item => {
        const itemTime = Number(item.dataset.time || 0);
        if (itemTime <= time) active = item;
      });
      items.forEach(i => i.classList.remove('active'));
      active?.classList.add('active');
      active?.scrollIntoView({ block: 'nearest' });
    }

    function renderTranscript(video) {
      const list = qs('#transcript-list');
      const summary = qs('#transcript-summary');
      const searchInput = qs('#transcript-search');
      if (!list || !summary) return;
      const transcript = getTranscript(video);
      const termo = (state.transcriptSearch || '').toLowerCase();
      const filtrado = termo ? transcript.filter(line => line.text.toLowerCase().includes(termo)) : transcript;
      summary.textContent = termo
        ? `${filtrado.length} de ${transcript.length} trechos para "${state.transcriptSearch}"`
        : `${transcript.length} linha(s) sincronizadas.`;
      list.innerHTML = '';
      if (!filtrado.length) {
        list.innerHTML = '<p style="color: var(--muted);">Nenhum trecho encontrado para este termo.</p>';
        return;
      }
      filtrado.forEach(line => {
        const item = document.createElement('div');
        item.className = 'transcript-item';
        item.dataset.time = String(line.time);
        item.id = `trans-${line.id}`;
        const timeEl = document.createElement('span');
        timeEl.className = 'timestamp';
        timeEl.textContent = secondsToClock(line.time);
        const textEl = document.createElement('div');
        textEl.textContent = line.text;
        item.append(timeEl, textEl);
        item.addEventListener('click', () => setPlayerPosition(line.time, true));
        list.appendChild(item);
      });
      if (searchInput && !searchInput.value && termo) {
        searchInput.value = state.transcriptSearch;
      }
      highlightTranscriptByTime(state.player.position || 0);
    }

    function setPlayerPosition(seconds, sincronizarTranscricao = false) {
      const duration = Math.max(1, Math.round((state.currentVideo?.duration || 1) * 60));
      state.player.duration = duration;
      state.player.position = Math.min(Math.max(0, seconds), duration);
      syncPlayerStatus();
      if (sincronizarTranscricao) highlightTranscriptByTime(state.player.position);
    }

    function persistAutoplay() {
      storage.save(AUTOPLAY_KEY, !!state.autoplay);
    }

    function updateAutoplayUI() {
      const btn = qs('#autoplay-toggle');
      if (!btn) return;
      btn.textContent = state.autoplay ? 'Ativada' : 'Desativada';
      btn.setAttribute('aria-pressed', String(!!state.autoplay));
    }

    function persistSettings() {
      storage.save(SETTINGS_KEY, state.settings);
    }

    function applySettings() {
      document.body.dataset.theme = state.settings.theme;
      document.body.dataset.contrast = state.settings.contrast;
      document.documentElement.style.setProperty('--font-scale', state.settings.fontScale);
    }

    function updateSettingsForm() {
      const theme = qs('#setting-theme');
      const contrast = qs('#setting-contrast');
      const font = qs('#setting-font');
      const profile = qs('#setting-profile');
      const push = qs('#setting-push');
      const digest = qs('#setting-digest');
      if (theme) theme.value = state.settings.theme;
      if (contrast) contrast.value = state.settings.contrast;
      if (font) font.value = state.settings.fontScale;
      if (profile) profile.checked = !!state.settings.privacyProfile;
      if (push) push.checked = !!state.settings.notifPush;
      if (digest) digest.checked = !!state.settings.notifDigest;
    }

    function getUpNextQueue(currentId) {
      const base = aplicarFiltros(state.videos, { searchTerm: '' });
      return base.filter(video => video.id !== currentId);
    }

    function renderUpNext(currentId) {
      const container = qs('#up-next');
      const list = qs('#up-next-list');
      if (!container || !list) return;
      const fila = getUpNextQueue(currentId);
      const proximo = fila[0];
      container.innerHTML = '';
      list.innerHTML = '';
      if (!proximo) {
        container.innerHTML = '<p style="color: var(--muted);">Nenhum v√≠deo para tocar em seguida.</p>';
        return;
      }
      const avatarHtml = avatarTemplate(avatarInfo({ username: proximo.owner, channel: proximo.channel }));
      const destaque = document.createElement('div');
      destaque.className = 'video-card up-next-card';
      destaque.innerHTML = `
        <div class="thumb">
          <img src="${proximo.thumb}" alt="Thumbnail do pr√≥ximo v√≠deo" loading="lazy" decoding="async">
          <div class="badge">${minutesToDuration(proximo.duration)}</div>
        </div>
        <div class="card-body">
          ${avatarHtml}
          <div class="card-text">
            <h4>${escapeHTML(proximo.title)}</h4>
            <p>${escapeHTML(proximo.channel)} ¬∑ ${proximo.views} visualiza√ß√µes</p>
          </div>
        </div>
      `;
      destaque.addEventListener('click', () => openWatch(proximo.id));
      container.appendChild(destaque);

      fila.slice(1, 4).forEach(video => {
        const item = document.createElement('div');
        item.className = 'video-card';
        item.innerHTML = `
          <div class="thumb" style="aspect-ratio:16/9;">
            <img src="${video.thumb}" alt="Thumbnail sugerida" loading="lazy" decoding="async">
            <div class="badge">${minutesToDuration(video.duration)}</div>
          </div>
          <div class="card-body" style="grid-template-columns:1fr;">
            <div class="card-text">
              <h4>${escapeHTML(video.title)}</h4>
              <p>${escapeHTML(video.channel)} ¬∑ ${video.views} visualiza√ß√µes</p>
            </div>
          </div>
        `;
        item.addEventListener('click', () => openWatch(video.id));
        list.appendChild(item);
      });
    }

    function syncPlayerStatus() {
      const bar = qs('#player-progress');
      const status = qs('#player-status');
      const duration = Math.max(1, state.player.duration || Math.round((state.currentVideo?.duration || 1) * 60));
      const pos = Math.min(Math.max(0, state.player.position || 0), duration);
      if (bar) bar.style.width = `${Math.min(100, (pos / duration) * 100)}%`;
      if (status) status.textContent = `${state.player.playing ? 'Reproduzindo' : 'Pausado'} ¬∑ ${secondsToClock(pos)} / ${secondsToClock(duration)} ¬∑ Vol ${Math.round((state.player.volume || 0) * 100)}%`;
    }

    function togglePlayback() {
      state.player.playing = !state.player.playing;
      syncPlayerStatus();
    }

    function adjustPosition(delta) {
      setPlayerPosition((state.player.position || 0) + delta, true);
    }

    function adjustVolume(delta) {
      state.player.volume = Math.min(1, Math.max(0, (state.player.volume || 0) + delta));
      syncPlayerStatus();
    }

    let playerTimer = null;
    let autoplayQueued = false;

    function handleAutoplayAdvance() {
      if (!state.autoplay || !state.currentVideo || autoplayQueued) return;
      const nextVideo = getUpNextQueue(state.currentVideo.id)[0];
      if (!nextVideo) return;
      autoplayQueued = true;
      showToast('Reprodu√ß√£o autom√°tica: iniciando pr√≥ximo v√≠deo.');
      setTimeout(() => {
        autoplayQueued = false;
        openWatch(nextVideo.id);
      }, 400);
    }

    function ensurePlayerTimer() {
      if (playerTimer) return;
      playerTimer = setInterval(() => {
        if (qs('#watch-view').classList.contains('hidden')) return;
        if (!state.currentVideo || !state.player.playing) return;
        const duration = Math.max(1, state.player.duration || Math.round((state.currentVideo?.duration || 1) * 60));
        const nextPos = (state.player.position || 0) + 1;
        if (nextPos >= duration) {
          state.player.position = duration;
          state.player.playing = false;
          syncPlayerStatus();
          handleAutoplayAdvance();
          return;
        }
        setPlayerPosition(nextPos, true);
      }, 1000);
    }

    let shortcutsBound = false;
    function bindPlayerShortcuts() {
      if (shortcutsBound) return;
      document.addEventListener('keydown', handlePlayerShortcuts);
      shortcutsBound = true;
    }

    function unbindPlayerShortcuts() {
      if (!shortcutsBound) return;
      document.removeEventListener('keydown', handlePlayerShortcuts);
      shortcutsBound = false;
    }

    function handlePlayerShortcuts(ev) {
      if (qs('#watch-view').classList.contains('hidden')) return;
      if (!state.currentVideo) return;
      const tag = ev.target.tagName;
      if (['INPUT','TEXTAREA','SELECT','BUTTON'].includes(tag)) return;
      const key = ev.key.toLowerCase();
      if ([' ', 'k'].includes(key)) { ev.preventDefault(); togglePlayback(); return; }
      if (key === 'j' || ev.key === 'ArrowLeft') { ev.preventDefault(); adjustPosition(-10); return; }
      if (key === 'l' || ev.key === 'ArrowRight') { ev.preventDefault(); adjustPosition(10); return; }
      if (ev.key === 'ArrowUp') { ev.preventDefault(); adjustVolume(0.05); return; }
      if (ev.key === 'ArrowDown') { ev.preventDefault(); adjustVolume(-0.05); return; }
    }

    // Assistir depois e offline
    function persistWatchLater() {
      persistSharedState({ datasets: ['watchLater'] });
    }

    function persistPlaylists() {
      persistSharedState({ datasets: ['playlists'] });
    }

    function persistHistorico() {
      persistSharedState({ datasets: ['historico'] });
    }

    function persistSubscriptions() {
      persistSharedState({ datasets: ['subscriptions'] });
    }

    function toggleSubscription({ channelKey, channelName } = {}) {
      if (!state.user) return showToast('Fa√ßa login para se inscrever em canais.');
      if (!channelKey) return;
      const idx = state.subscriptions.indexOf(channelKey);
      if (idx >= 0) {
        state.subscriptions.splice(idx, 1);
        showToast('Inscri√ß√£o removida.');
      } else {
        state.subscriptions.unshift(channelKey);
        showToast(`Inscrito em ${channelName || 'novo canal'}.`);
      }
      persistSubscriptions();
      renderSubscriptions();
      atualizarEstadoInscricao();
      if (state.channelView?.key && state.channelView.key === channelKey) {
        renderChannelView(getChannelInfo({ username: channelKey, channel: channelName }));
      } else {
        const channelBtn = qs('#channel-subscribe');
        if (channelBtn && state.channelView?.key) {
          const subscribed = isSubscribedChannel(state.channelView.key);
          channelBtn.textContent = subscribed ? 'Inscrito' : 'Inscrever-se';
          channelBtn.setAttribute('aria-pressed', String(subscribed));
        }
      }
      refreshNotifications({ silent: true });
    }

    function toggleWatchLater(videoId) {
      if (!videoId) return;
      const idx = state.watchLater.indexOf(videoId);
      if (idx >= 0) {
        state.watchLater.splice(idx, 1);
        showToast('Removido de Assistir depois.');
      } else {
        state.watchLater.unshift(videoId);
        showToast('Adicionado em Assistir depois.');
      }
      persistWatchLater();
      atualizarAfinidade();
      renderGrid();
      renderWatchLater();
      atualizarEstadoWatchButtons(videoId);
    }

    function addToPlaylist(videoId, comToast = true) {
      if (!videoId) return;
      const exists = state.playlists.includes(videoId);
      if (!exists) {
        state.playlists.unshift(videoId);
        persistPlaylists();
        if (comToast) showToast('Adicionado √† playlist.');
      } else if (comToast) {
        showToast('Esse v√≠deo j√° est√° na playlist.');
      }
      atualizarAfinidade();
      renderPlaylists();
      atualizarEstadoWatchButtons(videoId);
    }

    function removeFromPlaylist(videoId) {
      const idx = state.playlists.indexOf(videoId);
      if (idx >= 0) {
        state.playlists.splice(idx, 1);
        persistPlaylists();
        atualizarAfinidade();
        renderPlaylists();
        atualizarEstadoWatchButtons(videoId);
      }
    }

    function addToHistory(videoId, silencioso = true) {
      if (!videoId) return;
      state.historico = state.historico.filter(id => id !== videoId);
      state.historico.unshift(videoId);
      state.historico = state.historico.slice(0, 200);
      persistHistorico();
      atualizarAfinidade();
      renderHistorico();
      renderRecommendations();
      renderTracks();
      if (!silencioso) showToast('Adicionado ao hist√≥rico.');
    }

    function saveOffline(videoId) {
      const video = state.videos.find(v => v.id === videoId);
      if (!video) return showToast('V√≠deo n√£o encontrado.');
      const existing = state.clips.find(c => c.offlineFrom === videoId || c.id === `offline-${videoId}`);
      if (existing) return showToast('J√° salvo para offline.');
      const clip = {
        id: `offline-${videoId}`,
        offlineFrom: videoId,
        title: video.title,
        duration: minutesToDuration(video.duration),
        views: video.views,
        thumb: video.thumb,
        status: 'baixando',
        category: video.category,
      };
      state.clips.unshift(clip);
      storage.save('mtube-clips', state.clips);
      atualizarAfinidade();
      renderClips();
      showToast('Salvando offline...');
      setTimeout(() => {
        clip.status = 'baixado';
        storage.save('mtube-clips', state.clips);
        atualizarAfinidade();
        renderClips();
        showToast('V√≠deo dispon√≠vel offline.');
      }, 400);
    }

    function resetPagination() {
      state.pagination.page = 1;
    }

    function renderGridSkeleton() {
      const grid = qs('#video-grid');
      if (!grid) return;
      grid.innerHTML = '';
      for (let i = 0; i < state.pagination.perPage; i++) {
        const skeleton = document.createElement('div');
        skeleton.className = 'video-card skeleton';
        skeleton.innerHTML = `
          <div class="thumb skeleton-thumb"></div>
          <div class="card-body">
            <div class="avatar skeleton-line" style="width:36px;height:36px;border-radius:50%;margin-right:8px;"></div>
            <div class="card-text">
              <div class="skeleton-line" style="width:80%;"></div>
              <div class="skeleton-line" style="width:60%;"></div>
            </div>
          </div>
        `;
        grid.appendChild(skeleton);
      }
    }

    function renderRecommendations() {
      const box = qs('#recommend-box');
      const list = qs('#recommendations');
      if (!box || !list) return;
      if (state.search.termo) { box.classList.add('hidden'); return; }
      const candidatos = aplicarFiltros(state.videos, { searchTerm: '' }).slice(0, 6);
      if (!candidatos.length) { box.classList.add('hidden'); return; }
      box.classList.remove('hidden');
      list.innerHTML = '';
      candidatos.forEach(video => {
        const card = document.createElement('div');
        card.className = 'video-card';
        card.style.minWidth = '240px';
        const avatarHtml = avatarTemplate(avatarInfo({ username: video.owner, channel: video.channel }));
        card.innerHTML = `
          <div class="thumb" style="aspect-ratio:16/9;">
            <img src="${video.thumb}" alt="Thumbnail" loading="lazy" decoding="async">
            <div class="badge">${minutesToDuration(video.duration)}</div>
          </div>
          <div class="card-body">
            ${avatarHtml}
            <div class="card-text">
              <h4>${escapeHTML(video.title)}</h4>
              <p>${escapeHTML(video.channel)} ¬∑ ${video.views} visualiza√ß√µes</p>
            </div>
          </div>
        `;
        card.addEventListener('click', () => openWatch(video.id));
        list.appendChild(card);
      });
    }

    function construirTrilhas() {
      const trilhas = [];
      const categoriasOrdenadas = Object.entries(state.afinidade.categorias || {})
        .sort((a, b) => b[1] - a[1])
        .map(([categoria]) => categoria)
        .slice(0, 3);
      categoriasOrdenadas.forEach(cat => {
        const vids = state.videos.filter(v => v.category === cat).slice(0, 8);
        if (vids.length) {
          trilhas.push({ titulo: `${cat} em alta`, itens: vids });
        }
      });
      const longos = state.videos.filter(v => (v.duration || 0) >= 8).slice(0, 8);
      if (longos.length) trilhas.push({ titulo: 'Para maratonar', itens: longos });
      const recentesHist = getHistoricoVideos().slice(0, 8);
      if (recentesHist.length) trilhas.push({ titulo: 'Baseado no seu hist√≥rico', itens: recentesHist });
      return trilhas;
    }

    function renderTracks() {
      const box = qs('#tracks-box');
      const row = qs('#tracks-row');
      if (!box || !row) return;
      if (state.search.termo) { box.classList.add('hidden'); return; }
      const trilhas = construirTrilhas();
      if (!trilhas.length) { box.classList.add('hidden'); return; }
      box.classList.remove('hidden');
      row.innerHTML = '';
      trilhas.forEach(trilha => {
        const card = document.createElement('div');
        card.className = 'track-card';
        card.innerHTML = `
          <h4>${escapeHTML(trilha.titulo)}</h4>
          <div class="track-meta">${trilha.itens.length} v√≠deo(s) ¬∑ ${trilha.itens[0]?.category || ''}</div>
          <p style="color:var(--muted);margin:6px 0 0;">Clique para abrir o primeiro e ver a trilha completa.</p>
        `;
        card.addEventListener('click', () => {
          if (trilha.itens[0]) openWatch(trilha.itens[0].id);
        });
        row.appendChild(card);
      });
    }

    function construirExplorarListas() {
      if (state.search.termo) return [];
      const base = aplicarFiltros(state.videos, { searchTerm: '' });
      const listas = [];
      const emAlta = base.slice(0, 10);
      if (emAlta.length) {
        listas.push({ titulo: 'Em alta', itens: emAlta });
      }
      const categorias = ['M√∫sica', 'Games', 'Filmes & TV', 'Entretenimento', 'Esportes'];
      categorias.forEach(cat => {
        const itens = base.filter(video => video.category === cat).slice(0, 10);
        if (itens.length) {
          listas.push({ titulo: cat, itens });
        }
      });
      return listas;
    }

    function renderExplore() {
      const container = qs('#explore-rows');
      const summary = qs('#explore-summary');
      if (!container) return;
      if (state.search.termo) {
        container.innerHTML = '';
        if (summary) summary.textContent = 'Limpe a busca para explorar listas tem√°ticas.';
        return;
      }
      const listas = construirExplorarListas();
      if (!listas.length) {
        container.innerHTML = '<p style="color: var(--muted);">Ainda n√£o h√° v√≠deos suficientes para montar o explorar.</p>';
        if (summary) summary.textContent = 'Nenhuma lista dispon√≠vel no momento.';
        return;
      }
      if (summary) {
        const categoria = state.filter.categoria === 'all' ? 'todas as categorias' : `categoria ${state.filter.categoria}`;
        summary.textContent = `Listas tem√°ticas com base nos filtros atuais (${categoria}, ${state.filter.ordem}, ${state.filter.duracao}).`;
      }
      container.innerHTML = '';
      listas.forEach(lista => {
        const bloco = document.createElement('div');
        bloco.className = 'explore-block';
        bloco.innerHTML = `
          <h4 class="section-title">${escapeHTML(lista.titulo)}</h4>
          <div class="explore-row"></div>
        `;
        const row = bloco.querySelector('.explore-row');
        renderVideoCards(lista.itens, row);
        container.appendChild(bloco);
      });
    }

    function calcularRelevancia(video, termo = '') {
      const search = (termo || '').toLowerCase();
      let score = 0;
      if (search) {
        const t = (video.title || '').toLowerCase();
        const d = (video.description || '').toLowerCase();
        const c = (video.category || '').toLowerCase();
        if (t.includes(search)) score += 8;
        if (d.includes(search)) score += 5;
        if (c.includes(search)) score += 3;
      }
      const afinidade = state.filter.afinidade ? pontuarAfinidade(video) * 2 : 0;
      if (state.filter.ordem === 'recentes') score += (video.createdAt || 0) / 1e10;
      if (state.filter.ordem === 'views') score += (video.views || 0) / 800;
      if (state.filter.ordem === 'avaliados') score += ((video.likes || 0) - (video.dislikes || 0)) / 8;
      score += (video.views || 0) * 0.001;
      score += Math.max(0, (video.likes || 0) - (video.dislikes || 0)) * 0.05;
      score += afinidade;
      return score;
    }

    function renderVideoCards(lista, container) {
      if (!container) return;
      container.innerHTML = '';
      if (!lista.length) {
        container.innerHTML = '<p style="color: var(--muted);">Nenhum v√≠deo encontrado neste canal.</p>';
        return;
      }
      lista.forEach(video => {
        const card = document.createElement('div');
        card.className = 'video-card';
        const avatarHtml = avatarTemplate(avatarInfo({ username: video.owner, channel: video.channel }));
        card.innerHTML = `
          <div class="thumb">
            <img src="${video.thumb}" alt="Thumbnail do v√≠deo" loading="lazy" decoding="async">
            <div class="badge">${minutesToDuration(video.duration)}</div>
          </div>
          <div class="card-body">
            ${avatarHtml}
            <div class="card-text">
              <h4>${escapeHTML(video.title)}</h4>
              <p>${escapeHTML(video.channel)} ¬∑ ${video.views} visualiza√ß√µes</p>
            </div>
          </div>
        `;
        card.addEventListener('click', () => openWatch(video.id));
        container.appendChild(card);
      });
    }

    function aplicarFiltros(lista, opts = {}) {
      const termoBusca = (opts.searchTerm ?? state.search.termo ?? '').toLowerCase();
      let filtrados = [...lista];
      if (state.filter.categoria !== 'all') {
        filtrados = filtrados.filter(v => v.category === state.filter.categoria);
      }
      if (state.filter.duracao !== 'todas') {
        filtrados = filtrados.filter(v => {
          const dur = Number(v.duration) || 0;
          if (state.filter.duracao === 'curtas') return dur <= 4;
          if (state.filter.duracao === 'medias') return dur >= 5 && dur <= 10;
          if (state.filter.duracao === 'longas') return dur > 10;
          return true;
        });
      }
      const decorados = filtrados.map(v => ({ video: v, score: calcularRelevancia(v, termoBusca) }));
      decorados.sort((a, b) => b.score - a.score || (b.video.createdAt || 0) - (a.video.createdAt || 0));
      return decorados.map(d => d.video);
    }

    function atualizarPainelBusca() {
      const box = qs('#search-results-box');
      const resumo = qs('#search-summary');
      const detalhe = qs('#search-detail');
      const lista = qs('#search-results-list');
      if (!box || !resumo || !lista) return;
      if (!state.search.termo) {
        box.classList.add('hidden');
        lista.innerHTML = '';
        return;
      }
      box.classList.remove('hidden');
      const total = state.search.resultados.length;
      resumo.textContent = total ? `Resultados para "${state.search.termo}" (${total})` : `Nenhum resultado para "${state.search.termo}"`;
      detalhe.textContent = total ? 'Use os bot√µes para navegar ou clique em um item abaixo.' : 'Tente outro termo ou limpe a busca para voltar ao feed completo.';
      lista.innerHTML = '';
      state.search.resultados.forEach((video, idx) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'search-chip' + (idx === state.search.indice ? ' active' : '');
        btn.textContent = video.title;
        btn.addEventListener('click', () => {
          state.search.indice = idx;
          atualizarPainelBusca();
          openWatch(video.id);
        });
        lista.appendChild(btn);
      });
    }

    function atualizarPaginacao(total, totalPages, pageItems) {
      const resumo = qs('#grid-summary');
      const prev = qs('#grid-prev');
      const next = qs('#grid-next');
      const paginaAtual = state.pagination.page;
      const inicio = total ? (pageItems.length ? (pageItems[0].indexRef + 1) : 0) : 0;
      const fim = total ? (pageItems.length ? (pageItems[pageItems.length - 1].indexRef + 1) : 0) : 0;
      if (resumo) {
        resumo.textContent = total ? `Exibindo ${inicio}‚Äì${fim} de ${total} v√≠deo(s)` : 'Nenhum v√≠deo encontrado para os filtros atuais.';
      }
      if (prev) prev.disabled = paginaAtual <= 1 || totalPages <= 1;
      if (next) next.disabled = paginaAtual >= totalPages || totalPages <= 1;
    }

    function renderGrid() {
      const grid = qs('#video-grid');
      if (!grid) return;
      renderGridSkeleton();

      const termoBusca = state.search.termo;
      const baseLista = termoBusca ? state.search.resultados : state.videos;
      const videosFiltrados = aplicarFiltros(baseLista, { searchTerm: termoBusca });
      renderRecommendations();
      renderTracks();
      renderExplore();
      const total = videosFiltrados.length;
      const totalPages = Math.max(1, Math.ceil(total / state.pagination.perPage));
      state.pagination.page = Math.min(state.pagination.page, totalPages);
      const start = (state.pagination.page - 1) * state.pagination.perPage;
      const end = start + state.pagination.perPage;

      const pageItems = videosFiltrados.slice(start, end).map((v, idx) => ({ ...v, indexRef: start + idx }));
      grid.innerHTML = '';

      if (!total) {
        grid.innerHTML = '<p style="color: var(--muted);">Nenhum v√≠deo encontrado para os filtros atuais. Ajuste a busca ou as op√ß√µes de categoria/ordem/dura√ß√£o.</p>';
        atualizarPaginacao(0, 1, []);
        return;
      }

      pageItems.forEach(video => {
        const card = document.createElement('div');
        const inWatchLater = state.watchLater.includes(video.id);
        const inPlaylist = state.playlists.includes(video.id);
        const inHistory = state.historico.includes(video.id);
        card.className = 'video-card';
        card.dataset.id = video.id;
        const titulo = termoBusca ? highlightTerm(video.title, termoBusca) : escapeHTML(video.title);
        const metaTexto = `${video.channel} ¬∑ ${video.views} visualiza√ß√µes ¬∑ ${timeAgo(video.createdAt)}`;
        const meta = termoBusca ? highlightTerm(metaTexto, termoBusca) : escapeHTML(metaTexto);
        const avatarHtml = avatarTemplate(avatarInfo({ username: video.owner, channel: video.channel }));
        card.innerHTML = `
          <div class="thumb">
            <img src="${video.thumb}" alt="Thumbnail" loading="lazy" decoding="async">
            <div class="badge">${minutesToDuration(video.duration)}</div>
          </div>
          <div class="card-body">
            ${avatarHtml}
            <div class="card-text">
              <h4>${titulo}</h4>
              <p>${meta}</p>
            </div>
          </div>
          <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;">
            <button class="pill-btn ghost watchlater-btn" data-id="${video.id}" aria-pressed="${inWatchLater}">${inWatchLater ? 'Remover' : 'Assistir depois'}</button>
            <button class="pill-btn ghost offline-btn" data-id="${video.id}">Salvar offline</button>
            <button class="pill-btn ghost playlist-btn" data-id="${video.id}" aria-pressed="${inPlaylist}">${inPlaylist ? 'Na playlist' : 'Adicionar √† playlist'}</button>
            <button class="pill-btn ghost history-btn" data-id="${video.id}" aria-pressed="${inHistory}">${inHistory ? 'No hist√≥rico' : 'Salvar hist√≥rico'}</button>
          </div>
        `;
        card.addEventListener('click', () => openWatch(video.id));
        card.querySelector('.watchlater-btn').addEventListener('click', (ev) => {
          ev.stopPropagation();
          toggleWatchLater(video.id);
        });
        card.querySelector('.offline-btn').addEventListener('click', (ev) => {
          ev.stopPropagation();
          saveOffline(video.id);
        });
        card.querySelector('.playlist-btn').addEventListener('click', (ev) => {
          ev.stopPropagation();
          addToPlaylist(video.id);
        });
        card.querySelector('.history-btn').addEventListener('click', (ev) => {
          ev.stopPropagation();
          addToHistory(video.id, false);
        });
        grid.appendChild(card);
      });

      atualizarPaginacao(total, totalPages, pageItems);
      const categories = qs('#categories');
      categories.classList.toggle('hidden', state.videos.length === 0);
      refreshNotifications({ silent: true });
    }

    function navegarPagina(delta) {
      const baseLista = state.search.termo ? state.search.resultados : state.videos;
      const total = aplicarFiltros(baseLista).length;
      const totalPages = Math.max(1, Math.ceil(total / state.pagination.perPage));
      state.pagination.page = Math.min(Math.max(1, state.pagination.page + delta), totalPages);
      renderGrid();
    }

    const renderGridDebounced = debounce(renderGrid, 250);
    const executarBuscaDebounced = debounce(() => executarBusca(true), 250);
    const executarBuscaDebouncedComFeedback = debounce(() => executarBusca(false), 250);

    function renderSubscriptions() {
      const grid = qs('#subscriptions-grid');
      const summary = qs('#subscriptions-summary');
      const empty = qs('#subscriptions-empty');
      if (!grid) return;
      const subscribedKeys = state.subscriptions || [];
      if (!subscribedKeys.length) {
        grid.innerHTML = '';
        if (summary) summary.textContent = 'Voc√™ ainda n√£o segue nenhum canal.';
        if (empty) empty.classList.remove('hidden');
        return;
      }
      if (empty) empty.classList.add('hidden');
      const videos = state.videos.filter(video => subscribedKeys.includes(getChannelKeyFromVideo(video)));
      if (summary) summary.textContent = `${videos.length} v√≠deo(s) dos canais que voc√™ segue.`;
      if (!videos.length) {
        grid.innerHTML = '<p style="color: var(--muted);">Ainda n√£o h√° v√≠deos publicados pelos canais que voc√™ segue.</p>';
        return;
      }
      renderVideoCards(videos, grid);
    }

    function renderClips() {
      const grid = qs('#clips-grid');
      grid.innerHTML = '';
      state.clips.forEach(clip => {
        const card = document.createElement('div');
        card.className = 'video-card';
        card.innerHTML = `
          <div class="thumb">
            <img src="${clip.thumb}" alt="Thumbnail clip">
            <div class="badge">${clip.duration}</div>
          </div>
          <div class="card-body">
            <div class="avatar">C</div>
            <div class="card-text">
              <h4>${clip.title}</h4>
              <p>${clip.views} visualiza√ß√µes${clip.status ? ' ¬∑ ' + clip.status : ''}</p>
            </div>
          </div>
        `;
        grid.appendChild(card);
      });
    }

    function getWatchLaterVideos() {
      return state.watchLater
        .map(id => state.videos.find(v => v.id === id))
        .filter(Boolean);
    }

    function getPlaylistVideos() {
      return state.playlists
        .map(id => state.videos.find(v => v.id === id))
        .filter(Boolean);
    }

    function getHistoricoVideos() {
      return state.historico
        .map(id => state.videos.find(v => v.id === id))
        .filter(Boolean);
    }

    function aplicarFiltrosWatchLater(lista) {
      let filtrados = [...lista];
      if (state.watchLaterFilter.categoria !== 'all') {
        filtrados = filtrados.filter(v => v.category === state.watchLaterFilter.categoria);
      }
      if (state.watchLaterFilter.ordem === 'recentes') {
        filtrados.sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
      } else if (state.watchLaterFilter.ordem === 'views') {
        filtrados.sort((a, b) => (b.views || 0) - (a.views || 0));
      } else if (state.watchLaterFilter.ordem === 'avaliados') {
        filtrados.sort((a, b) => ((b.likes || 0) - (b.dislikes || 0)) - ((a.likes || 0) - (a.dislikes || 0)));
      }
      return filtrados;
    }

    function renderWatchLater() {
      const grid = qs('#watchlater-grid');
      if (!grid) return;
      grid.innerHTML = '';
      const filtrados = aplicarFiltrosWatchLater(getWatchLaterVideos());
      if (!filtrados.length) {
        grid.innerHTML = '<p style="color: var(--muted);">Nada salvo em "Assistir depois". Clique no bot√£o nos cards ou no player para adicionar.</p>';
        return;
      }
      filtrados.forEach(video => {
        const card = document.createElement('div');
        card.className = 'video-card';
        card.dataset.id = video.id;
        card.innerHTML = `
          <div class="thumb">
            <img src="${video.thumb}" alt="Thumbnail">
            <div class="badge">${minutesToDuration(video.duration)}</div>
          </div>
          <div class="card-body">
            <div class="avatar">${video.channel.charAt(0).toUpperCase()}</div>
            <div class="card-text">
              <h4>${video.title}</h4>
              <p>${video.channel} ¬∑ ${video.views} visualiza√ß√µes ¬∑ ${timeAgo(video.createdAt)}</p>
            </div>
          </div>
          <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;">
            <button class="pill-btn ghost" data-action="open" data-id="${video.id}">Assistir agora</button>
            <button class="pill-btn ghost" data-action="remove" data-id="${video.id}">Remover</button>
          </div>
        `;
        card.addEventListener('click', () => openWatch(video.id));
        card.querySelector('[data-action="open"]').addEventListener('click', (ev) => {
          ev.stopPropagation();
          openWatch(video.id);
        });
        card.querySelector('[data-action="remove"]').addEventListener('click', (ev) => {
          ev.stopPropagation();
          toggleWatchLater(video.id);
        });
        grid.appendChild(card);
      });
    }

    function renderPlaylists() {
      const grid = qs('#playlist-grid');
      if (!grid) return;
      grid.innerHTML = '';
      const filtrados = aplicarFiltrosWatchLater(getPlaylistVideos());
      if (!filtrados.length) {
        grid.innerHTML = '<p style="color: var(--muted);">Nenhum item na playlist. Use os bot√µes dos cards ou do player para adicionar.</p>';
        return;
      }
      filtrados.forEach(video => {
        const card = document.createElement('div');
        card.className = 'video-card';
        card.dataset.id = video.id;
        const avatarHtml = avatarTemplate(avatarInfo({ username: video.owner, channel: video.channel }));
        card.innerHTML = `
          <div class="thumb">
            <img src="${video.thumb}" alt="Thumbnail playlist">
            <div class="badge">${minutesToDuration(video.duration)}</div>
          </div>
          <div class="card-body">
            ${avatarHtml}
            <div class="card-text">
              <h4>${video.title}</h4>
              <p>${video.channel} ¬∑ ${video.views} visualiza√ß√µes ¬∑ ${timeAgo(video.createdAt)}</p>
            </div>
          </div>
          <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;">
            <button class="pill-btn ghost" data-action="open" data-id="${video.id}">Assistir</button>
            <button class="pill-btn ghost" data-action="remove" data-id="${video.id}">Remover</button>
          </div>
        `;
        card.addEventListener('click', () => openWatch(video.id));
        card.querySelector('[data-action="open"]').addEventListener('click', (ev) => {
          ev.stopPropagation();
          openWatch(video.id);
        });
        card.querySelector('[data-action="remove"]').addEventListener('click', (ev) => {
          ev.stopPropagation();
          removeFromPlaylist(video.id);
        });
        grid.appendChild(card);
      });
    }

    function renderHistorico() {
      const grid = qs('#history-grid');
      if (!grid) return;
      grid.innerHTML = '';
      const filtrados = aplicarFiltrosWatchLater(getHistoricoVideos());
      if (!filtrados.length) {
        grid.innerHTML = '<p style="color: var(--muted);">Seu hist√≥rico est√° vazio. Ao assistir um v√≠deo ele aparece aqui.</p>';
        return;
      }
      filtrados.forEach(video => {
        const card = document.createElement('div');
        card.className = 'video-card';
        card.dataset.id = video.id;
        const avatarHtml = avatarTemplate(avatarInfo({ username: video.owner, channel: video.channel }));
        card.innerHTML = `
          <div class="thumb">
            <img src="${video.thumb}" alt="Thumbnail hist√≥rico">
            <div class="badge">${minutesToDuration(video.duration)}</div>
          </div>
          <div class="card-body">
            ${avatarHtml}
            <div class="card-text">
              <h4>${video.title}</h4>
              <p>${video.channel} ¬∑ ${video.views} visualiza√ß√µes ¬∑ ${timeAgo(video.createdAt)}</p>
            </div>
          </div>
          <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;">
            <button class="pill-btn ghost" data-action="open" data-id="${video.id}">Rever</button>
            <button class="pill-btn ghost" data-action="remove" data-id="${video.id}">Remover</button>
          </div>
        `;
        card.addEventListener('click', () => openWatch(video.id));
        card.querySelector('[data-action="open"]').addEventListener('click', (ev) => {
          ev.stopPropagation();
          openWatch(video.id);
        });
        card.querySelector('[data-action="remove"]').addEventListener('click', (ev) => {
          ev.stopPropagation();
          state.historico = state.historico.filter(id => id !== video.id);
          persistHistorico();
          renderHistorico();
        });
        grid.appendChild(card);
      });
    }

    function ativarAbaBiblioteca(tab) {
      const clipsGrid = qs('#clips-grid');
      const watchLaterGrid = qs('#watchlater-grid');
      const playlistGrid = qs('#playlist-grid');
      const historyGrid = qs('#history-grid');
      const filters = qs('#watchlater-filters');
      const tabClips = qs('#tab-clips');
      const tabWatch = qs('#tab-watchlater');
      const tabPlay = qs('#tab-playlists');
      const tabHist = qs('#tab-history');
      if (!clipsGrid || !watchLaterGrid || !tabClips || !tabWatch || !playlistGrid || !historyGrid || !tabPlay || !tabHist) return;
      const tabs = ['clips', 'watchlater', 'playlists', 'history'];
      const elements = { clips: tabClips, watchlater: tabWatch, playlists: tabPlay, history: tabHist };
      const grids = { clips: clipsGrid, watchlater: watchLaterGrid, playlists: playlistGrid, history: historyGrid };
      tabs.forEach(name => {
        const isActive = tab === name;
        elements[name].classList.toggle('active', isActive);
        elements[name].setAttribute('aria-pressed', String(isActive));
        grids[name].classList.toggle('hidden', !isActive);
      });
      filters?.classList.toggle('hidden', tab === 'clips');
      if (tab === 'watchlater') renderWatchLater();
      if (tab === 'playlists') renderPlaylists();
      if (tab === 'history') renderHistorico();
    }

    function renderSuggestions(currentId) {
      const box = qs('#suggestions');
      box.innerHTML = '';
      state.videos.filter(v => v.id !== currentId).slice(0,6).forEach(video => {
        const item = document.createElement('div');
        item.className = 'video-card';
        item.style.gridTemplateColumns = '120px 1fr';
        const avatarHtml = avatarTemplate(avatarInfo({ username: video.owner, channel: video.channel }));
        item.innerHTML = `
          <div class="thumb" style="aspect-ratio:16/9;">
            <img src="${video.thumb}" alt="Thumb sugerido">
            <div class="badge">${minutesToDuration(video.duration)}</div>
          </div>
          <div class="card-body" style="grid-template-columns:1fr;">
            <div class="card-text">
              <h4>${video.title}</h4>
              <p>${video.channel} ¬∑ ${video.views} visualiza√ß√µes</p>
            </div>
            <div style="display:flex;align-items:center;gap:8px;margin-top:6px;">${avatarHtml}<span style="color:var(--muted);font-size:13px;">${escapeHTML(video.channel)}</span></div>
          </div>
        `;
        item.addEventListener('click', () => openWatch(video.id));
        box.appendChild(item);
      });
    }

    function limparBusca() {
      state.search = { termo: '', resultados: [], indice: 0 };
      qs('#search').value = '';
      atualizarPainelBusca();
      resetPagination();
      renderGrid();
    }

    function executarBusca(silencioso = false) {
      const termo = qs('#search').value.trim().toLowerCase();
      if (!termo) {
        limparBusca();
        return;
      }
      const resultados = state.videos
        .filter(v =>
          v.title.toLowerCase().includes(termo) ||
          v.description.toLowerCase().includes(termo) ||
          v.channel.toLowerCase().includes(termo) ||
          v.category.toLowerCase().includes(termo)
        )
        .map(v => ({ video: v, score: calcularRelevancia(v, termo) }))
        .sort((a, b) => b.score - a.score)
        .map(item => item.video);
      state.search = { termo, resultados, indice: 0 };
      atualizarPainelBusca();
      resetPagination();
      renderGrid();
      if (!silencioso) {
        showToast(resultados.length ? `${resultados.length} resultado(s) encontrados.` : 'Nenhum v√≠deo encontrado.');
      }
    }

    function navegarResultado(delta) {
      if (!state.search.resultados.length) return;
      const total = state.search.resultados.length;
      state.search.indice = (state.search.indice + delta + total) % total;
      atualizarPainelBusca();
      const atual = state.search.resultados[state.search.indice];
      if (atual) openWatch(atual.id);
    }

    function setChannelTab(tab) {
      state.channelView.tab = tab;
      qsa('.channel-tab').forEach(btn => {
        const active = btn.dataset.tab === tab;
        btn.classList.toggle('active', active);
        btn.setAttribute('aria-selected', String(active));
      });
      qsa('.channel-section').forEach(section => {
        section.classList.toggle('hidden', section.id !== `channel-section-${tab}`);
      });
    }

    function renderChannelView(info) {
      const avatarEl = qs('#channel-avatar');
      const nameEl = qs('#channel-name');
      const metaEl = qs('#channel-meta');
      const aboutEl = qs('#channel-about');
      const subscribeBtn = qs('#channel-subscribe');
      if (nameEl) nameEl.textContent = info.name;
      if (avatarEl) {
        if (info.avatar) {
          avatarEl.classList.add('img');
          avatarEl.innerHTML = `<img src="${info.avatar}" alt="Avatar do canal ${escapeHTML(info.name)}">`;
        } else {
          avatarEl.classList.remove('img');
          avatarEl.textContent = info.name.charAt(0).toUpperCase();
        }
      }
      const videos = getChannelVideos(info);
      const totalViews = videos.reduce((sum, v) => sum + (v.views || 0), 0);
      if (metaEl) metaEl.textContent = `${videos.length} v√≠deo(s) ¬∑ ${totalViews} visualiza√ß√µes`;
      if (aboutEl) aboutEl.textContent = info.description;
      if (subscribeBtn) {
        const subscribed = isSubscribedChannel(info.key);
        subscribeBtn.textContent = subscribed ? 'Inscrito' : 'Inscrever-se';
        subscribeBtn.setAttribute('aria-pressed', String(subscribed));
        subscribeBtn.dataset.channelKey = info.key;
        subscribeBtn.dataset.channelName = info.name;
      }
      renderVideoCards(videos.slice(0, 6), qs('#channel-featured'));
      renderVideoCards(videos, qs('#channel-videos'));
      setChannelTab(state.channelView.tab || 'inicio');
    }

    function openChannelView({ username, channel } = {}) {
      const info = getChannelInfo({ username, channel });
      state.channelView.key = info.key;
      state.channelView.tab = state.channelView.tab || 'inicio';
      renderChannelView(info);
      showSection('channel');
    }

    function openWatch(id, opts = {}) {
      const video = state.videos.find(v => v.id === id);
      if (!video) return;
      state.currentVideo = video;
      autoplayQueued = false;
      if (!opts.skipViewIncrement) {
        video.views += 1;
        persistSharedState({ datasets: ['videos'] });
      }
      qs('#watch-title').textContent = video.title;
      qs('#watch-desc').textContent = video.description;
      qs('#watch-stats').textContent = `${video.channel} ¬∑ ${video.views} visualiza√ß√µes ¬∑ ${timeAgo(video.createdAt)}`;
      const authorBox = qs('#watch-author');
      if (authorBox) {
        const info = avatarInfo({ username: video.owner, channel: video.channel });
        authorBox.innerHTML = `
          ${avatarTemplate(info)}
          <div>
            <button class="channel-link" type="button" data-channel="${escapeHTML(info.name)}" data-owner="${escapeHTML(video.owner || '')}">
              ${escapeHTML(info.name)}
            </button>
            <p style="margin:2px 0 0;color:var(--muted);font-size:13px;">Criador ‚Ä¢ ${video.category || 'Sem categoria'}</p>
          </div>
        `;
      }
      qs('#like-count').textContent = video.likes || 0;
      qs('#dislike-count').textContent = video.dislikes || 0;
      qs('#player-thumb').style.background = `center / cover url(${video.thumb})`;
      if (!opts.skipHistory) addToHistory(video.id, true);
      state.transcriptSearch = '';
      state.player = { duration: Math.max(1, Math.round((video.duration || 1) * 60)), position: 0, playing: false, volume: state.player?.volume ?? 0.8 };
      const transcriptInput = qs('#transcript-search');
      if (transcriptInput) transcriptInput.value = '';
      showSection('watch');
      renderSuggestions(id);
      renderUpNext(id);
      renderComments(id);
      atualizarEstadoInscricao();
      atualizarEstadoWatchButtons(id);
      renderChapters(video);
      renderTranscript(video);
      syncPlayerStatus();
      updateAutoplayUI();
      ensurePlayerTimer();
    }

    function atualizarEstadoInscricao() {
      const btn = qs('#action-subscribe');
      if (!btn) return;
      const video = state.currentVideo;
      if (!video) return;
      const channelKey = getChannelKeyFromVideo(video);
      const subscribed = channelKey && isSubscribedChannel(channelKey);
      btn.textContent = subscribed ? 'Inscrito' : 'Inscrever-se';
      btn.setAttribute('aria-pressed', String(!!subscribed));
      btn.dataset.channelKey = channelKey;
      btn.dataset.channelName = video.channel || '';
    }

    function atualizarEstadoWatchButtons(videoId) {
      const wl = qs('#action-watchlater');
      const off = qs('#action-offline');
      const pl = qs('#action-playlist');
      const hist = qs('#action-history');
      const inList = state.watchLater.includes(videoId);
      if (wl) {
        wl.textContent = inList ? 'Remover da lista' : 'Assistir depois';
        wl.setAttribute('aria-pressed', String(inList));
      }
      if (off) {
        const offline = state.clips.some(c => c.offlineFrom === videoId || c.id === `offline-${videoId}`);
        off.textContent = offline ? 'Offline dispon√≠vel' : 'Salvar offline';
        off.disabled = offline;
        off.setAttribute('aria-disabled', String(offline));
      }
      const inPlaylist = state.playlists.includes(videoId);
      if (pl) {
        pl.textContent = inPlaylist ? 'Na playlist' : 'Adicionar √† playlist';
        pl.setAttribute('aria-pressed', String(inPlaylist));
      }
      const inHistory = state.historico.includes(videoId);
      if (hist) {
        hist.textContent = inHistory ? 'No hist√≥rico' : 'Salvar hist√≥rico';
        hist.setAttribute('aria-pressed', String(inHistory));
      }
    }

    function likeVideo(delta) {
      if (!state.currentVideo) return;
      const vid = state.currentVideo;
      vid.likes = (vid.likes || 0) + (delta === 'up' ? 1 : 0);
      vid.dislikes = (vid.dislikes || 0) + (delta === 'down' ? 1 : 0);
      persistSharedState({ datasets: ['videos'] });
      qs('#like-count').textContent = vid.likes;
      qs('#dislike-count').textContent = vid.dislikes;
    }

    // Navega√ß√£o
    function showView(view) {
      qs('#login-view').classList.add('hidden');
      qs('#signup-view').classList.add('hidden');
      qs('#app').classList.add('hidden');
      if (view === 'login') qs('#login-view').classList.remove('hidden');
      if (view === 'signup') qs('#signup-view').classList.remove('hidden');
      if (view === 'app') qs('#app').classList.remove('hidden');
    }

    function showSection(section) {
      qs('#home-view').classList.add('hidden');
      qs('#watch-view').classList.add('hidden');
      qs('#channel-view').classList.add('hidden');
      qs('#subscriptions-view').classList.add('hidden');
      qs('#explore-view').classList.add('hidden');
      qs('#settings-view').classList.add('hidden');
      qs('#clips-view').classList.add('hidden');
      if (section === 'home') qs('#home-view').classList.remove('hidden');
      if (section === 'watch') {
        qs('#watch-view').classList.remove('hidden');
        bindPlayerShortcuts();
      }
      if (section === 'channel') {
        qs('#channel-view').classList.remove('hidden');
      }
      if (section === 'subscriptions') {
        qs('#subscriptions-view').classList.remove('hidden');
        renderSubscriptions();
      }
      if (section === 'explore') {
        qs('#explore-view').classList.remove('hidden');
        renderExplore();
      }
      if (section === 'settings') {
        qs('#settings-view').classList.remove('hidden');
        updateSettingsForm();
      }
      if (section === 'clips') {
        qs('#clips-view').classList.remove('hidden');
        ativarAbaBiblioteca('clips');
      }
      qsa('.nav-item').forEach(item => item.classList.toggle('active', item.dataset.view === section));
      if (section !== 'watch') unbindPlayerShortcuts();
    }

    // Upload
    function renderThumbGallery() {
      const gallery = qs('#thumb-gallery');
      gallery.innerHTML = '';
      defaultThumbs.forEach((src, idx) => {
        const opt = document.createElement('label');
        opt.className = 'thumb-option';
        opt.innerHTML = `<img src="${src}" alt="Thumb ${idx+1}"><input type="radio" name="thumb" value="${src}" ${idx===0?'checked':''}>`;
        gallery.appendChild(opt);
      });
    }

    function renderAvatarGallery(selected) {
      const gallery = qs('#avatar-gallery');
      if (!gallery) return;
      gallery.innerHTML = '';
      defaultAvatars.forEach((src, idx) => {
        const option = document.createElement('label');
        option.className = 'avatar-option';
        option.innerHTML = `
          <div class="avatar img" style="margin:0 auto 6px;">
            <img src="${src}" alt="Avatar sugerido ${idx+1}">
          </div>
          <input type="radio" name="profile-avatar-option" value="${src}">
          <span style="font-size:12px;color:var(--muted);">Sugest√£o ${idx+1}</span>
        `;
        const input = option.querySelector('input');
        if (selected && selected === src) {
          option.classList.add('active');
          input.checked = true;
        }
        option.addEventListener('click', () => {
          qsa('input[name="profile-avatar-option"]').forEach(i => i.checked = false);
          input.checked = true;
          qsa('.avatar-option').forEach(el => el.classList.remove('active'));
          option.classList.add('active');
          qs('#profile-avatar').value = src;
          atualizarPreviewPerfil();
        });
        gallery.appendChild(option);
      });
    }

    function atualizarPreviewPerfil() {
      const name = (qs('#profile-display')?.value || state.user?.display || state.user?.username || 'Usu√°rio').trim();
      const avatarUrl = (qs('#profile-avatar')?.value || '').trim();
      const preview = qs('#profile-avatar-preview');
      const nameEl = qs('#profile-preview-name');
      if (nameEl) nameEl.textContent = name || 'Usu√°rio';
      if (preview) {
        if (avatarUrl) {
          preview.classList.add('img');
          preview.innerHTML = `<img src="${avatarUrl}" alt="Avatar pr√©-visualiza√ß√£o">`;
        } else {
          preview.classList.remove('img');
          preview.textContent = (name || 'U').charAt(0).toUpperCase();
        }
      }
    }

    function openUpload() { qs('#upload-modal').style.display = 'flex'; }
    function closeUpload() { qs('#upload-modal').style.display = 'none'; }

    function openProfile() {
      if (!state.user) { showToast('Fa√ßa login para editar seu perfil.'); return; }
      qs('#profile-display').value = state.user.display || state.user.username;
      qs('#profile-avatar').value = state.user.avatar || '';
      renderAvatarGallery(state.user.avatar || '');
      atualizarPreviewPerfil();
      qs('#profile-modal').style.display = 'flex';
    }

    function closeProfile() { qs('#profile-modal').style.display = 'none'; }

    function openNotifPanel() {
      if (!state.user) {
        showToast('Fa√ßa login para ver notifica√ß√µes.');
        return;
      }
      refreshNotifications({ silent: true });
      const panel = qs('#notif-panel');
      const btn = qs('#notif-btn');
      if (!panel || !btn) return;
      panel.classList.remove('hidden');
      panel.setAttribute('aria-hidden', 'false');
      btn.setAttribute('aria-expanded', 'true');
      markNotificationsRead();
    }

    function closeNotifPanel() {
      const panel = qs('#notif-panel');
      const btn = qs('#notif-btn');
      if (!panel || !btn) return;
      panel.classList.add('hidden');
      panel.setAttribute('aria-hidden', 'true');
      btn.setAttribute('aria-expanded', 'false');
    }

    function toggleNotifPanel() {
      const panel = qs('#notif-panel');
      if (!panel) return;
      if (panel.classList.contains('hidden')) {
        openNotifPanel();
      } else {
        closeNotifPanel();
      }
    }

    function renderUserChip(profile) {
      const chipAvatar = qs('#user-chip-avatar');
      const nameEl = qs('#user-name');
      if (nameEl) nameEl.textContent = profile.display || profile.username;
      if (chipAvatar) {
        if (profile.avatar) {
          chipAvatar.classList.add('img');
          chipAvatar.innerHTML = `<img src="${profile.avatar}" alt="Avatar do usu√°rio">`;
        } else {
          chipAvatar.classList.remove('img');
          chipAvatar.textContent = (profile.display || profile.username || 'U').charAt(0).toUpperCase();
        }
      }
    }

    function aplicarPerfilAtualizado(partial) {
      if (!state.user) return;
      const username = state.user.username;
      const atual = state.users.find(u => u.username === username) || state.user;
      const atualizado = { ...atual, ...partial, username };
      const antigoDisplay = atual.display;
      const idx = state.users.findIndex(u => u.username === username);
      if (idx >= 0) {
        state.users[idx] = atualizado;
      } else {
        state.users.push(atualizado);
      }
      state.user = atualizado;
      renderUserChip(atualizado);

      // Atualiza v√≠deos do usu√°rio para refletir display/avatar novos
      state.videos = state.videos.map(video => {
        const mesmoAutor = video.owner === username || (!video.owner && video.channel === antigoDisplay);
        if (mesmoAutor) {
          return { ...video, owner: username, channel: atualizado.display || username };
        }
        return video;
      });

      persistSharedState({ datasets: ['users', 'videos'] });
      renderGrid();
      renderClips();
      renderWatchLater();
      renderPlaylists();
      renderHistorico();
      if (state.currentVideo) openWatch(state.currentVideo.id, { skipViewIncrement: true, skipHistory: true });
      showToast('Perfil atualizado e sincronizado.');
    }

    function handleProfileSave(ev) {
      ev.preventDefault();
      if (!state.user) { showToast('Fa√ßa login para salvar o perfil.'); return; }
      const display = qs('#profile-display').value.trim() || state.user.username;
      const avatar = (qs('#profile-avatar').value || '').trim();
      aplicarPerfilAtualizado({ display, avatar });
      closeProfile();
    }

    function handleUpload(e) {
      e.preventDefault();
      const title = qs('#video-title').value.trim();
      const description = qs('#video-desc').value.trim();
      const duration = Number(qs('#video-duration').value) || 1;
      const category = qs('#video-category').value;
      const thumb = (qs('input[name="thumb"]:checked')?.value) || defaultThumbs[0];
      if (!title || !description) return showToast('Preencha t√≠tulo e descri√ß√£o.');
      const video = {
        id: 'v-' + crypto.randomUUID(),
        title,
        description,
        duration,
        category,
        thumb,
        owner: state.user?.username,
        channel: state.user?.display || state.user?.username || 'Criador',
        views: 0,
        likes: 0,
        dislikes: 0,
        createdAt: Date.now(),
      };
      state.videos.unshift(video);
      persistSharedState({ datasets: ['videos'] });
      atualizarAfinidade();
      renderGrid();
      closeUpload();
      showToast('V√≠deo publicado e adicionado ao feed.');
    }

      // Autentica√ß√£o
        const SESSION_EXPIRED_MESSAGE = 'Sess√£o expirada. Fa√ßa login novamente.';

          const sessionTokensValidos = (tokens) => !!(tokens?.token && tokens?.expiresAt && tokens.expiresAt > Date.now());

          const emitirTokensLocais = (username) => ({
            username,
            token: `token-local-${username}-${crypto.randomUUID()}`,
            refreshToken: `refresh-local-${username}-${crypto.randomUUID()}`,
            expiresAt: Date.now() + SESSION_TOKEN_TTL_MS,
          });

          async function emitirTokensSeguros(username, passwordHash) {
            try {
              const { tokens, profile } = await remoteApi.loginSession({ username, password: passwordHash });
              if (profile) {
                const idx = state.users.findIndex(u => u.username === profile.username);
                if (idx >= 0) state.users[idx] = { ...state.users[idx], ...profile };
              }
              return tokens || emitirTokensLocais(username);
            } catch (err) {
              console.warn('Falha ao emitir tokens remotos, usando local', err);
              return emitirTokensLocais(username);
            }
          }

        async function renovarTokens(refreshToken) {
          try {
            const { tokens, profile } = await remoteApi.refreshSession({ refreshToken });
            if (profile) {
              const idx = state.users.findIndex(u => u.username === profile.username);
              if (idx >= 0) state.users[idx] = { ...state.users[idx], ...profile };
            }
            return tokens;
          } catch (err) {
            console.warn('Falha ao renovar sess√£o remota', err);
            return null;
          }
        }

        async function hidratarPerfilRemoto(username) {
          try {
            const snapshot = await remoteApi.fetchSnapshot();
            const perfil = snapshot?.users?.find(u => u.username === username);
            if (perfil) {
              const idx = state.users.findIndex(u => u.username === username);
              if (idx >= 0) {
                state.users[idx] = { ...state.users[idx], ...perfil };
              } else {
                state.users.push(perfil);
              }
              persistSharedState({ datasets: ['users'], skipRemoteSync: true });
              return perfil;
            }
          } catch (err) {
            console.warn('Falha ao hidratar perfil remoto', err);
          }
          return null;
        }

          function persistSession(session) {
            state.session = session;
            storage.save('mtube-session', session);
            if (session) enqueueRemoteSync('session', session);
          }

        function limparSessao() {
          persistSession(null);
          persistSessionTokens(null);
          state.user = null;
        }

        function sessaoValida(session) {
          return !!(session && session.username && session.expiresAt && session.expiresAt > Date.now());
        }

      async function handleSignup(ev) {
        ev.preventDefault();
        const username = qs('#signup-username').value.trim();
        const password = qs('#signup-password').value;
        const display = qs('#signup-display').value.trim() || username;
        if (state.users.find(u => u.username === username)) return showToast('Usu√°rio j√° existe.');
        const hash = await sha256(password);
        const user = { username, password: hash, display };
        state.users.push(user);
        persistSharedState({ datasets: ['users'] });
        showToast('Conta criada. Fa√ßa login.');
        showView('login');
      }

    async function handleLogin(ev) {
      ev.preventDefault();
      const username = qs('#login-username').value.trim();
        const password = qs('#login-password').value;
        const hash = await sha256(password);
        const found = state.users.find(u => u.username === username && u.password === hash);
        if (!found) return showToast('Usu√°rio ou senha inv√°lidos.');
        const tokens = await emitirTokensSeguros(username, hash);
        persistSessionTokens(tokens);
        const perfilAtualizado = state.users.find(u => u.username === username) || found;
        state.user = perfilAtualizado;
        if (qs('#remember').checked) {
          persistSession({ username, expiresAt: Date.now() + SESSION_TTL_MS, refreshToken: tokens.refreshToken });
        } else {
          persistSession(null);
        }
        renderUserChip(perfilAtualizado);
        showView('app');
        showSection('home');
        renderGrid();
        renderClips();
        renderSubscriptions();
        hydrateNotifications();
    }

        async function logout() {
          try { await remoteApi.logoutSession(); } catch (err) { console.warn('Falha ao encerrar sess√£o remota', err); }
          limparSessao();
          state.notifications = { items: [], lastSeen: 0, unread: 0 };
          renderNotificationUI();
          showView('login');
        }

        async function tryAutoLogin() {
          const session = state.session;
          if (!sessaoValida(session)) {
            if (session) showToast(SESSION_EXPIRED_MESSAGE);
            limparSessao();
            showView('login');
            return;
          }
          let tokens = state.sessionTokens || loadSessionTokens();
          if (!sessionTokensValidos(tokens) && session?.refreshToken) {
            const refreshed = await renovarTokens(session.refreshToken);
            if (refreshed) {
              tokens = refreshed;
              persistSessionTokens(tokens);
            }
          }
          if (!sessionTokensValidos(tokens)) {
            showToast(SESSION_EXPIRED_MESSAGE);
            limparSessao();
            showView('login');
            return;
          }
          const found = state.users.find(u => u.username === session.username);
          if (!found) {
            limparSessao();
            showView('login');
            return;
          }
          const perfilAtualizado = await hidratarPerfilRemoto(session.username) || found;
          state.user = perfilAtualizado;
          renderUserChip(perfilAtualizado);
          showView('app');
          showSection('home');
          renderGrid();
          renderClips();
          renderSubscriptions();
          hydrateNotifications();
        }

    // Eventos
    function bindEvents() {
      qs('#go-signup').addEventListener('click', () => showView('signup'));
      qs('#back-login').addEventListener('click', () => showView('login'));
      qs('#signup-form').addEventListener('submit', handleSignup);
      qs('#login-form').addEventListener('submit', handleLogin);
      qsa('.nav-item').forEach(item => item.addEventListener('click', () => {
        const view = item.dataset.view;
        if (view === 'upload') return openUpload();
        if (item.id === 'nav-profile') return openProfile();
        showSection(view === 'home' ? 'home' : view);
      }));
      qs('#nav-logout').addEventListener('click', logout);
      qs('#user-chip').addEventListener('click', openProfile);
      qs('#open-upload').addEventListener('click', openUpload);
      const notifBtn = qs('#notif-btn');
      const notifPanel = qs('#notif-panel');
      const notifWrapper = qs('.notif-wrapper');
      notifBtn?.addEventListener('click', (ev) => {
        ev.stopPropagation();
        toggleNotifPanel();
      });
      qs('#notif-mark-read')?.addEventListener('click', () => markNotificationsRead());
      qs('#notif-list')?.addEventListener('click', (ev) => {
        const item = ev.target.closest('.notif-item');
        if (!item) return;
        const videoId = item.dataset.videoId;
        const notifId = item.dataset.notifId;
        if (notifId) {
          state.notifications.items = state.notifications.items.map(notif => (
            notif.id === notifId ? { ...notif, read: true } : notif
          ));
          state.notifications.unread = countUnreadNotifications(state.notifications.items);
          saveNotifications();
          renderNotificationUI();
        }
        if (videoId) openWatch(videoId);
        closeNotifPanel();
      });
      document.addEventListener('click', (ev) => {
        if (!notifPanel || notifPanel.classList.contains('hidden')) return;
        if (!notifWrapper?.contains(ev.target)) closeNotifPanel();
      });
      document.addEventListener('keydown', (ev) => {
        if (ev.key === 'Escape') closeNotifPanel();
      });
      qs('#from-hero-upload').addEventListener('click', openUpload);
      qs('#cancel-upload').addEventListener('click', closeUpload);
      qs('#cancel-profile').addEventListener('click', closeProfile);
      qs('#profile-form').addEventListener('submit', handleProfileSave);
      qs('#profile-display').addEventListener('input', atualizarPreviewPerfil);
      qs('#profile-avatar').addEventListener('input', atualizarPreviewPerfil);
      qs('#upload-form').addEventListener('submit', handleUpload);
      const settingsForm = qs('#settings-form');
      if (settingsForm) settingsForm.addEventListener('submit', (ev) => {
        ev.preventDefault();
        state.settings = {
          theme: qs('#setting-theme').value,
          contrast: qs('#setting-contrast').value,
          fontScale: Number(qs('#setting-font').value),
          privacyProfile: qs('#setting-profile').checked,
          notifPush: qs('#setting-push').checked,
          notifDigest: qs('#setting-digest').checked,
        };
        persistSettings();
        applySettings();
        showToast('Configura√ß√µes salvas.');
      });
      qs('#settings-reset')?.addEventListener('click', () => {
        state.settings = defaultSettings();
        persistSettings();
        applySettings();
        updateSettingsForm();
        showToast('Configura√ß√µes restauradas.');
      });
      qs('#setting-font')?.addEventListener('input', () => {
        state.settings.fontScale = Number(qs('#setting-font').value);
        applySettings();
      });
      qs('#search-btn').addEventListener('click', () => executarBuscaDebouncedComFeedback());
      const searchInput = qs('#search');
      searchInput.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') executarBusca(); });
      searchInput.addEventListener('input', () => executarBuscaDebounced());
      qsa('.filter-pill').forEach(pill => pill.addEventListener('click', () => {
        qsa('.filter-pill').forEach(p => p.classList.remove('active'));
        pill.classList.add('active');
        state.filter.categoria = pill.dataset.filter;
        resetPagination();
        renderGridDebounced();
      }));
      const channelTabs = qsa('.channel-tab');
      channelTabs.forEach(tab => tab.addEventListener('click', () => {
        setChannelTab(tab.dataset.tab);
      }));
      qs('#watch-author')?.addEventListener('click', (ev) => {
        const target = ev.target.closest('.channel-link');
        if (!target) return;
        openChannelView({ username: target.dataset.owner, channel: target.dataset.channel });
      });
      const ordemSelect = qs('#order-select');
      const duracaoSelect = qs('#duration-select');
      ordemSelect.addEventListener('change', () => { state.filter.ordem = ordemSelect.value; resetPagination(); renderGridDebounced(); });
      duracaoSelect.addEventListener('change', () => { state.filter.duracao = duracaoSelect.value; resetPagination(); renderGridDebounced(); });
      qs('#prev-result').addEventListener('click', () => navegarResultado(-1));
      qs('#next-result').addEventListener('click', () => navegarResultado(1));
      qs('#open-current').addEventListener('click', () => {
        const atual = state.search.resultados[state.search.indice];
        if (atual) openWatch(atual.id);
      });
      qs('#clear-search').addEventListener('click', limparBusca);
      qs('#action-like').addEventListener('click', () => likeVideo('up'));
      qs('#action-dislike').addEventListener('click', () => likeVideo('down'));
      qs('#action-subscribe').addEventListener('click', () => {
        if (!state.currentVideo) return showToast('Abra um v√≠deo primeiro.');
        const key = getChannelKeyFromVideo(state.currentVideo);
        toggleSubscription({ channelKey: key, channelName: state.currentVideo.channel });
      });
      qs('#action-watchlater').addEventListener('click', () => {
        if (!state.currentVideo) return showToast('Abra um v√≠deo primeiro.');
        toggleWatchLater(state.currentVideo.id);
      });
      qs('#action-offline').addEventListener('click', () => {
        if (!state.currentVideo) return showToast('Abra um v√≠deo primeiro.');
        saveOffline(state.currentVideo.id);
      });
      qs('#action-playlist').addEventListener('click', () => {
        if (!state.currentVideo) return showToast('Abra um v√≠deo primeiro.');
        addToPlaylist(state.currentVideo.id);
      });
      qs('#action-history').addEventListener('click', () => {
        if (!state.currentVideo) return showToast('Abra um v√≠deo primeiro.');
        addToHistory(state.currentVideo.id, false);
      });
      qs('#autoplay-toggle').addEventListener('click', () => {
        state.autoplay = !state.autoplay;
        persistAutoplay();
        updateAutoplayUI();
        showToast(state.autoplay ? 'Reprodu√ß√£o autom√°tica ativada.' : 'Reprodu√ß√£o autom√°tica desativada.');
      });
      qs('#channel-subscribe')?.addEventListener('click', () => {
        const channelKey = state.channelView?.key;
        if (!channelKey) return;
        const info = getChannelInfo({ username: channelKey });
        toggleSubscription({ channelKey, channelName: info.name });
      });
      const commentForm = qs('#comment-form');
      if (commentForm) commentForm.addEventListener('submit', (ev) => {
        ev.preventDefault();
        if (!state.currentVideo) return showToast('Abra um v√≠deo para comentar.');
        const text = qs('#comment-text').value;
        addComment(state.currentVideo.id, text);
        qs('#comment-text').value = '';
      });
      const commentList = qs('#comments-list');
      if (commentList) commentList.addEventListener('click', (ev) => {
        const btn = ev.target.closest('[data-comment-action]');
        if (!btn) return;
        if (btn.dataset.commentAction === 'report') {
          reportComment(btn.dataset.id);
        } else {
          reactToComment(btn.dataset.id, btn.dataset.commentAction);
        }
      });
      const transcriptSearch = qs('#transcript-search');
      transcriptSearch?.addEventListener('input', debounce(() => {
        state.transcriptSearch = transcriptSearch.value.trim();
        if (state.currentVideo) renderTranscript(state.currentVideo);
      }, 200));
      const tabClips = qs('#tab-clips');
      const tabWatch = qs('#tab-watchlater');
      const tabPlay = qs('#tab-playlists');
      const tabHist = qs('#tab-history');
      tabClips?.addEventListener('click', () => ativarAbaBiblioteca('clips'));
      tabWatch?.addEventListener('click', () => ativarAbaBiblioteca('watchlater'));
      tabPlay?.addEventListener('click', () => ativarAbaBiblioteca('playlists'));
      tabHist?.addEventListener('click', () => ativarAbaBiblioteca('history'));
      const wlOrder = qs('#wl-order');
      const wlCat = qs('#wl-category');
      wlOrder?.addEventListener('change', () => {
        state.watchLaterFilter.ordem = wlOrder.value;
        renderWatchLater();
        renderPlaylists();
        renderHistorico();
      });
      wlCat?.addEventListener('change', () => {
        state.watchLaterFilter.categoria = wlCat.value;
        renderWatchLater();
        renderPlaylists();
        renderHistorico();
      });
      qs('#grid-prev')?.addEventListener('click', () => navegarPagina(-1));
      qs('#grid-next')?.addEventListener('click', () => navegarPagina(1));
    }

    // Bootstrap com sincroniza√ß√£o remota
    async function bootstrap() {
      await syncFromRemote({ silent: true });
      ensureSeedVideos();
      atualizarAfinidade();
      renderThumbGallery();
      applySettings();
        bindEvents();
      updateAutoplayUI();
        await tryAutoLogin();
      renderNotificationUI();
      atualizarPainelBusca();
      renderGrid();
      renderClips();
      renderWatchLater();
      renderPlaylists();
      renderHistorico();
      if (!state.user) showView('login');
    }

    bootstrap();
  </script>
</body>
</html>
